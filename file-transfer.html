<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Secure File Transfer - A.Insiders</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  
  <!-- Favicon Setup -->
  <link rel="icon" type="image/png" href="ainsiders-logo.png" id="main-favicon">
  <link rel="apple-touch-icon" href="ainsiders-logo.png">
  <meta name="description" content="Secure end-to-end encrypted file transfer using WebRTC and AES-256 encryption. Transfer files directly between devices without server storage.">
  <meta name="keywords" content="file transfer, encryption, WebRTC, secure, P2P, A.Insiders">
  
  <!-- Security Headers -->
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="X-Frame-Options" content="DENY">
  <meta http-equiv="X-XSS-Protection" content="1; mode=block">
  <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
  <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=()">
  
  <!-- Enhanced Cache Control Headers -->
  <meta http-equiv="Cache-Control" content="public, max-age=31536000, immutable, stale-while-revalidate=86400">
  <meta http-equiv="Expires" content="31536000">
  <meta http-equiv="ETag" content="file-transfer-v1.0">
  <meta http-equiv="Last-Modified" content="2023-12-31T00:00:00Z">
  
  <!-- Optimized Asset Caching System -->
  <link rel="stylesheet" href="brain-styles.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
  
  <!-- Preload critical assets -->
  <link rel="preload" href="brain-script.js?v=1.0" as="script" crossorigin="anonymous">
  <link rel="preload" href="shared-loader.js?v=1.0" as="script" crossorigin="anonymous">
  <link rel="preload" href="mobile-nav.js?v=1.0" as="script" crossorigin="anonymous">
  <link rel="preload" href="sphere-loader.js?v=1.0" as="script" crossorigin="anonymous">
  <link rel="preload" href="ainsiders-logo.png?v=1.0" as="image" type="image/png">
  <link rel="preload" href="logo.svg?v=1.0" as="image" type="image/svg+xml">
  
  <!-- Cache Manager and Asset Preloader -->
  <script src="browser-cache-manager.js"></script>
  <script src="asset-preloader.js"></script>
  
  <!-- Optimized Background System -->
  <script src="brain-script.js"></script>
  
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer">
  
  <!-- Favicon Animation Script -->
  <script src="favicon-animation.js"></script>
  
  <!-- File Transfer Specific Styles -->
  <style>
    /* Modern File Transfer Page Styling */
    body.file-transfer-page {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
      color: #ffffff !important;
      min-height: 100vh;
    }
    
    body.file-transfer-page::before {
      display: block !important;
      background: 
        radial-gradient(circle at 20% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
    }
    
    /* Modern Navigation */
    body.file-transfer-page .navbar {
      background: rgba(255, 255, 255, 0.1) !important;
      backdrop-filter: blur(20px) !important;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2) !important;
    }
    
    body.file-transfer-page .nav-logo .logo-text,
    body.file-transfer-page .nav-logo .logo-accent {
      color: #ffffff !important;
    }
    
    body.file-transfer-page .nav-link {
      color: #ffffff !important;
    }
    
    body.file-transfer-page .nav-link:hover {
      color: rgba(255, 255, 255, 0.8) !important;
    }
    
    /* Modern Hero Section */
    body.file-transfer-page .page-hero {
      background: rgba(255, 255, 255, 0.1) !important;
      backdrop-filter: blur(20px) !important;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2) !important;
    }
    
    body.file-transfer-page .page-title {
      color: #ffffff !important;
      font-size: 3rem !important;
      font-weight: 700 !important;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3) !important;
    }
    
    body.file-transfer-page .page-subtitle {
      color: rgba(255, 255, 255, 0.9) !important;
      font-size: 1.2rem !important;
    }
    
    /* Navigation styling for file transfer page - frosty white */
    body.file-transfer-page .navbar {
      background: rgba(255, 255, 255, 0.95) !important;
      backdrop-filter: blur(20px) !important;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
    }
    
    body.file-transfer-page .nav-logo .logo-text,
    body.file-transfer-page .nav-logo .logo-accent {
      color: #000000 !important;
    }
    
    body.file-transfer-page .nav-link {
      color: #000000 !important;
    }
    
    body.file-transfer-page .nav-link:hover {
      color: #666666 !important;
    }
    
    body.file-transfer-page .nav-dropdown .dropdown-menu {
      background: rgba(255, 255, 255, 0.95) !important;
      backdrop-filter: blur(20px) !important;
      border: 1px solid #000000 !important;
    }
    
    body.file-transfer-page .nav-dropdown .dropdown-link {
      color: #000000 !important;
    }
    
    body.file-transfer-page .nav-dropdown .dropdown-link:hover {
      background: rgba(0, 0, 0, 0.1) !important;
      color: #000000 !important;
    }
    
    /* Hero section styling */
    body.file-transfer-page .page-hero {
      background: rgba(255, 255, 255, 0.95) !important;
      backdrop-filter: blur(20px) !important;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
    }
    
    body.file-transfer-page .page-title {
      color: #000000 !important;
    }
    
    body.file-transfer-page .page-subtitle {
      color: #333333 !important;
    }
    
    /* Footer styling for file transfer page */
    body.file-transfer-page .footer {
      background: rgba(255, 255, 255, 0.95) !important;
      backdrop-filter: blur(20px) !important;
      border-top: 1px solid #000000 !important;
    }
    
    body.file-transfer-page .footer h4 {
      color: #000000 !important;
    }
    
    body.file-transfer-page .footer p {
      color: #333333 !important;
    }
    
    body.file-transfer-page .footer a {
      color: #000000 !important;
    }
    
    body.file-transfer-page .footer a:hover {
      color: #666666 !important;
    }
    
    body.file-transfer-page .footer .social-link {
      color: #000000 !important;
    }
    
    body.file-transfer-page .footer .social-link:hover {
      color: #666666 !important;
    }
    
    /* Mobile navigation styling for file transfer page */
    body.file-transfer-page .nav-toggle {
      background: rgba(255, 255, 255, 0.95) !important;
      border: 1px solid rgba(0, 0, 0, 0.1) !important;
    }
    
    body.file-transfer-page .nav-toggle span {
      background: #000000 !important;
    }
    
    body.file-transfer-page .nav-toggle:hover {
      background: rgba(255, 255, 255, 1) !important;
    }
    
    body.file-transfer-page .nav-toggle:hover span {
      background: #333333 !important;
    }
    
    body.file-transfer-page .nav-menu {
      background: rgba(255, 255, 255, 0.95) !important;
      backdrop-filter: blur(20px) !important;
      border: 1px solid rgba(0, 0, 0, 0.1) !important;
    }
    
    body.file-transfer-page .nav-menu .nav-link {
      color: #000000 !important;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
    }
    
    body.file-transfer-page .nav-menu .nav-link:hover {
      background: rgba(0, 0, 0, 0.05) !important;
      color: #000000 !important;
    }
    /* Modern Container Layout */
    .file-transfer-container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 2rem;
      display: grid;
      gap: 2rem;
    }
    
    /* Modern Glass Cards */
    .transfer-card {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 2.5rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    
    .transfer-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    }
    
    .transfer-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
      border-color: rgba(255, 255, 255, 0.3);
    }
    
    .transfer-card h2 {
      margin: 0 0 1.5rem 0;
      font-size: 1.8rem;
      font-weight: 700;
      color: #ffffff;
      display: flex;
      align-items: center;
      gap: 1rem;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    
    .transfer-card h2 i {
      font-size: 1.5rem;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .transfer-card p {
      margin: 0 0 1.5rem 0;
      line-height: 1.7;
      color: rgba(255, 255, 255, 0.9);
      font-size: 1.1rem;
    }
    
    /* Modern Role Selector */
    .role-selector {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    
    .role-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      padding: 2rem 1.5rem;
      color: white;
      font-size: 1.2rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(10px);
    }
    
    .role-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: left 0.5s;
    }
    
    .role-btn:hover::before {
      left: 100%;
    }
    
    .role-btn:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
      border-color: rgba(255, 255, 255, 0.4);
      background: rgba(255, 255, 255, 0.15);
    }
    
    .role-btn.active {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      border-color: transparent;
      transform: scale(1.02);
      box-shadow: 0 8px 30px rgba(79, 172, 254, 0.4);
    }
    
    .role-btn i {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }
    
    /* Modern Input Section */
    .room-input-section {
      display: flex;
      gap: 1rem;
      align-items: center;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }
    
    .room-input {
      flex: 1;
      min-width: 200px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 1.2rem 1.5rem;
      color: #ffffff;
      font-size: 1.1rem;
      font-weight: 500;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }
    
    .room-input:focus {
      outline: none;
      border-color: rgba(255, 255, 255, 0.5);
      background: rgba(255, 255, 255, 0.15);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
    }
    
    .room-input::placeholder {
      color: rgba(255, 255, 255, 0.6);
    }
    
    .connect-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      border-radius: 12px;
      padding: 1.2rem 2.5rem;
      color: white;
      font-weight: 600;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      white-space: nowrap;
      position: relative;
      overflow: hidden;
    }
    
    .connect-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }
    
    .connect-btn:hover::before {
      left: 100%;
    }
    
    .connect-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    }
    
    .connect-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .transfer-ui {
      display: none;
    }
    
    .transfer-ui.active {
      display: block;
    }
    
    /* Modern File Drop Zone */
    .file-drop-zone {
      border: 3px dashed rgba(255, 255, 255, 0.3);
      border-radius: 20px;
      padding: 4rem 2rem;
      text-align: center;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      margin-bottom: 1.5rem;
      min-height: 250px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #ffffff;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
    }
    
    .file-drop-zone::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.05) 50%, transparent 70%);
      transform: translateX(-100%);
      transition: transform 0.6s;
    }
    
    .file-drop-zone:hover::before {
      transform: translateX(100%);
    }
    
    .file-drop-zone:hover {
      border-color: rgba(255, 255, 255, 0.6);
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
    }
    
    .file-drop-zone.dragover {
      border-color: #4facfe;
      background: rgba(79, 172, 254, 0.2);
      transform: scale(1.02);
    }
    
    .file-drop-zone i {
      font-size: 4rem;
      margin-bottom: 1.5rem;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .file-drop-zone p {
      font-size: 1.2rem;
      font-weight: 500;
      margin-bottom: 0.5rem;
    }
    
    .file-drop-zone small {
      font-size: 0.9rem;
      opacity: 0.7;
    }
    
    .file-info {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 1.5rem;
      margin: 1.5rem 0;
      font-family: 'Inter', sans-serif;
      font-size: 1rem;
      color: #ffffff;
      border: 1px solid rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(10px);
    }
    
    .file-info strong {
      color: rgba(255, 255, 255, 0.9);
      font-weight: 600;
    }
    
    /* Modern Progress Bar */
    .progress-container {
      margin: 1.5rem 0;
    }
    
    .progress-bar {
      width: 100%;
      height: 12px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 1rem;
      position: relative;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      width: 0%;
      transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    
    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      animation: shimmer 2s infinite;
    }
    
    @keyframes shimmer {
      0% { left: -100%; }
      100% { left: 100%; }
    }
    
    .stats {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }
    
    .stat-item {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 0.75rem 1.2rem;
      font-size: 1rem;
      font-weight: 500;
      backdrop-filter: blur(10px);
      color: #ffffff;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    /* Modern Status Indicators */
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 1rem 1.5rem;
      border-radius: 12px;
      margin: 1.5rem 0;
      font-weight: 600;
      color: #ffffff;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s ease;
    }
    
    .status-indicator.connecting {
      background: rgba(255, 193, 7, 0.2);
      color: #ffd700;
      border-color: rgba(255, 193, 7, 0.3);
    }
    
    .status-indicator.connected {
      background: rgba(40, 167, 69, 0.2);
      color: #90EE90;
      border-color: rgba(40, 167, 69, 0.3);
    }
    
    .status-indicator.error {
      background: rgba(220, 53, 69, 0.2);
      color: #ff6b6b;
      border-color: rgba(220, 53, 69, 0.3);
    }
    
    .status-indicator i {
      font-size: 1.2rem;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* Modern Security Code Display */
    .sas-code {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 16px;
      padding: 2rem;
      text-align: center;
      font-weight: 700;
      margin: 1.5rem 0;
      font-family: 'Courier New', monospace;
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      position: relative;
      overflow: hidden;
    }
    
    .sas-code::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
      transform: translateX(-100%);
      transition: transform 0.6s;
    }
    
    .sas-code:hover::before {
      transform: translateX(100%);
    }
    
    .sas-code strong {
      display: block;
      margin-bottom: 1rem;
      font-size: 1.1rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .sas-code span {
      font-size: 1.5rem;
      letter-spacing: 2px;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    
    .key-status {
      margin-top: 1rem;
      font-size: 1rem;
      font-weight: 500;
      font-family: 'Inter', sans-serif;
      color: rgba(255, 255, 255, 0.9);
      padding: 0.5rem 1rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      display: inline-block;
    }
    
    /* Modern Action Buttons */
    .action-buttons {
      display: flex;
      gap: 1rem;
      margin: 1.5rem 0;
      flex-wrap: wrap;
    }
    
    .action-btn {
      padding: 1rem 2rem;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      white-space: nowrap;
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(10px);
    }
    
    .action-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }
    
    .action-btn:hover::before {
      left: 100%;
    }
    
    .action-btn.primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .action-btn.secondary {
      background: rgba(255, 255, 255, 0.1);
      color: #ffffff;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .action-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    }
    
    .action-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .hidden {
      display: none !important;
    }
    
    /* Modern Responsive Design */
    @media (max-width: 768px) {
      .file-transfer-container {
        padding: 1rem;
        gap: 1.5rem;
      }
      
      .transfer-card {
        padding: 1.5rem;
        border-radius: 16px;
      }
      
      .transfer-card h2 {
        font-size: 1.5rem;
      }
      
      .role-selector {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
      
      .role-btn {
        padding: 1.5rem 1rem;
      }
      
      .room-input-section {
        flex-direction: column;
        align-items: stretch;
        gap: 1rem;
      }
      
      .room-input {
        min-width: auto;
        padding: 1rem 1.2rem;
      }
      
      .connect-btn {
        padding: 1rem 2rem;
        width: 100%;
      }
      
      .stats {
        flex-direction: column;
        gap: 0.5rem;
      }
      
      .action-buttons {
        flex-direction: column;
        gap: 0.75rem;
      }
      
      .action-btn {
        width: 100%;
        padding: 1rem 1.5rem;
      }
      
      .file-drop-zone {
        padding: 2rem 1rem;
        min-height: 200px;
      }
      
      .file-drop-zone i {
        font-size: 3rem;
      }
      
      .sas-code {
        padding: 1.5rem;
      }
      
      .sas-code span {
        font-size: 1.2rem;
      }
    }
    
    /* Loading Animation */
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: #ffffff;
      animation: spin 1s ease-in-out infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Success Animation */
    .success-checkmark {
      display: inline-block;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #28a745;
      position: relative;
      animation: checkmark 0.5s ease-in-out;
    }
    
    .success-checkmark::after {
      content: '✓';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-weight: bold;
    }
    
    @keyframes checkmark {
      0% { transform: scale(0); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    
    /* Error Animation */
    .error-x {
      display: inline-block;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #dc3545;
      position: relative;
      animation: errorX 0.5s ease-in-out;
    }
    
    .error-x::after {
      content: '✕';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-weight: bold;
    }
    
    @keyframes errorX {
      0% { transform: scale(0); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    
    /* Modern Notification System */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 1rem 1.5rem;
      color: white;
      font-weight: 500;
      z-index: 10000;
      transform: translateX(100%);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      max-width: 400px;
    }
    
    .notification.show {
      transform: translateX(0);
    }
    
    .notification-content {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    
    .notification-icon {
      flex-shrink: 0;
    }
    
    .notification-close {
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.7);
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 4px;
      transition: all 0.2s ease;
      margin-left: auto;
    }
    
    .notification-close:hover {
      color: white;
      background: rgba(255, 255, 255, 0.1);
    }
    
    .notification-success {
      border-color: rgba(40, 167, 69, 0.3);
      background: rgba(40, 167, 69, 0.1);
    }
    
    .notification-error {
      border-color: rgba(220, 53, 69, 0.3);
      background: rgba(220, 53, 69, 0.1);
    }
    
         .notification-info {
       border-color: rgba(0, 123, 255, 0.3);
       background: rgba(0, 123, 255, 0.1);
     }
     
     /* Connection Data Sharing Styles */
     .connection-data {
       margin-top: 2rem;
       padding-top: 2rem;
       border-top: 1px solid rgba(255, 255, 255, 0.2);
     }
     
     .connection-data h3 {
       margin: 0 0 1rem 0;
       font-size: 1.3rem;
       font-weight: 600;
       color: #ffffff;
       display: flex;
       align-items: center;
       gap: 0.75rem;
     }
     
     .data-section {
       margin-bottom: 1.5rem;
     }
     
     .data-section label {
       display: block;
       margin-bottom: 0.5rem;
       font-weight: 600;
       color: rgba(255, 255, 255, 0.9);
     }
     
     .data-section textarea {
       width: 100%;
       min-height: 120px;
       background: rgba(255, 255, 255, 0.1);
       border: 2px solid rgba(255, 255, 255, 0.2);
       border-radius: 8px;
       padding: 1rem;
       color: #ffffff;
       font-family: 'Courier New', monospace;
       font-size: 0.9rem;
       resize: vertical;
       backdrop-filter: blur(10px);
       transition: all 0.3s ease;
     }
     
     .data-section textarea:focus {
       outline: none;
       border-color: rgba(255, 255, 255, 0.5);
       background: rgba(255, 255, 255, 0.15);
     }
     
     .data-section textarea::placeholder {
       color: rgba(255, 255, 255, 0.5);
     }
     
     .data-section button {
       margin-top: 0.5rem;
     }
  </style>
</head>
<body class="file-transfer-page">
  <!-- Loading Screen -->
  <div id="loader" class="loader">
    <canvas></canvas>
    <div class="spark-text">Secure File Transfer</div>
    <div class="continue-text">Click Anywhere To Continue</div>
  </div>

  <!-- Website Content -->
  <div id="website-content" class="website-content">

  <!-- Navigation -->
  <nav class="navbar">
    <div class="nav-container">
      <a href="index.html" class="nav-logo">
        <img src="ainsiders-logo.png" alt="A.Insiders Logo" class="logo-image" width="40" height="40">
        <span class="logo-text">A.I</span>
        <span class="logo-accent">NSIDERS</span>
      </a>
      <ul class="nav-menu">
        <li><a href="index.html" class="nav-link">Home</a></li>
        <li><a href="software.html" class="nav-link">Software</a></li>
        <li class="nav-dropdown">
          <div class="nav-link-container">
            <a href="about.html" class="nav-link">About</a>
            <span class="dropdown-arrow">▼</span>
          </div>
          <ul class="dropdown-menu">
            <li><a href="about.html" class="dropdown-link">About Company</a></li>
            <li><a href="blake-zimmerman.html" class="dropdown-link">Blake Zimmerman</a></li>
            <li><a href="babu-narayana.html" class="dropdown-link">Babu Narayana</a></li>
          </ul>
        </li>
        <li><a href="contact.html" class="nav-link">Contact</a></li>
      </ul>
      <div class="nav-toggle">
        <span></span>
        <span></span>
        <span></span>
      </div>
    </div>
  </nav>

  <!-- Hero Section -->
  <header class="page-hero">
    <canvas id="aiCanvas"></canvas>
    <div class="hero-content">
      <h1 class="page-title">Secure File Transfer</h1>
      <p class="page-subtitle">End-to-end encrypted file transfer using WebRTC and AES-256 encryption</p>
    </div>
  </header>

  <!-- File Transfer Tool -->
  <div class="file-transfer-container">
    <!-- File System Permissions -->
    <div class="transfer-card">
      <h2><i class="fas fa-shield-alt"></i> File System Access</h2>
      <p>
        This tool requires file system permissions for secure file transfer. 
        Click the button below to grant access to your files.
      </p>
      <button class="action-btn primary" id="requestPermissionsBtn">
        <i class="fas fa-key"></i> Grant File Access
      </button>
      <div class="status-indicator" id="permissionStatus">
        <i class="fas fa-circle"></i>
        <span>File access not granted</span>
      </div>
    </div>

    <!-- Role Selection -->
    <div class="transfer-card">
      <h2><i class="fas fa-users"></i> Select Your Role</h2>
      <div class="role-selector">
        <button class="role-btn" id="senderBtn">
          <i class="fas fa-upload fa-2x"></i>
          <span>I'm Sending Files</span>
        </button>
        <button class="role-btn" id="receiverBtn">
          <i class="fas fa-download fa-2x"></i>
          <span>I'm Receiving Files</span>
        </button>
      </div>
    </div>

         <!-- Connection Info -->
     <div class="transfer-card">
       <h2><i class="fas fa-wifi"></i> Direct P2P Connection</h2>
       <p>
         This tool uses WebRTC for direct peer-to-peer file transfer. No server setup required! 
         Files are transferred directly between browsers using public STUN/TURN servers.
       </p>
       <div class="status-indicator" id="connectionInfo">
         <i class="fas fa-info-circle"></i>
         <span>Ready for direct connection</span>
       </div>
     </div>

         <!-- Room Connection -->
     <div class="transfer-card" id="connectionCard">
       <h2><i class="fas fa-link"></i> Direct Connection</h2>
       <div class="room-input-section">
         <input type="text" class="room-input" id="roomCode" placeholder="Enter room code (e.g., ABC123)" maxlength="6">
         <button class="action-btn secondary" id="generateRoomBtn" style="display: none;">
           <i class="fas fa-refresh"></i> New Code
         </button>
         <button class="connect-btn" id="connectBtn">
           <i class="fas fa-plug"></i> Start Connection
         </button>
       </div>
       <div class="status-indicator" id="connectionStatus">
         <i class="fas fa-circle"></i>
         <span>Not connected</span>
       </div>
       
       <!-- Connection Data Sharing -->
       <div class="connection-data hidden" id="connectionData">
         <h3><i class="fas fa-share-alt"></i> Share Connection Data</h3>
         <p>Share this data with the other user to establish the P2P connection:</p>
         
         <div class="data-section">
           <label>Connection Data:</label>
           <textarea id="connectionDataText" readonly placeholder="Connection data will appear here..."></textarea>
           <button class="action-btn secondary" id="copyDataBtn">
             <i class="fas fa-copy"></i> Copy Data
           </button>
         </div>
         
         <div class="data-section">
           <label>Receive Connection Data:</label>
           <textarea id="receivedDataText" placeholder="Paste connection data from the other user here..."></textarea>
           <button class="action-btn primary" id="processDataBtn">
             <i class="fas fa-arrow-right"></i> Process Data
           </button>
         </div>
       </div>
     </div>

    <!-- Sender UI -->
    <div class="transfer-card transfer-ui" id="senderUI">
      <h2><i class="fas fa-upload"></i> Send File</h2>
             <div class="file-drop-zone" id="fileDropZone">
         <i class="fas fa-cloud-upload-alt"></i>
         <p>Drag and drop files here or click to browse</p>
         <small>
           <i class="fas fa-info-circle"></i> Click anywhere in this area to select a file
         </small>
         <input type="file" id="fileInput" style="display: none;">
       </div>
      
      <div class="file-info hidden" id="fileInfo"></div>
      
      <div class="progress-container hidden" id="sendProgress">
        <div class="progress-bar">
          <div class="progress-fill" id="sendProgressFill"></div>
        </div>
        <div class="stats">
          <div class="stat-item" id="sendRate">0 MB/s</div>
          <div class="stat-item" id="sendSent">0 MB sent</div>
        </div>
      </div>
      
      <div class="sas-code hidden" id="senderSAS">
        <strong>Security Code:</strong> <span id="senderSASCode">—</span>
        <div class="key-status" id="senderKeyStatus"></div>
      </div>
      
      <div class="action-buttons">
        <button class="action-btn primary" id="startSendBtn" disabled>
          <i class="fas fa-play"></i> Start Transfer
        </button>
      </div>
    </div>

    <!-- Receiver UI -->
    <div class="transfer-card transfer-ui" id="receiverUI">
      <h2><i class="fas fa-download"></i> Receive File</h2>
      
      <div class="file-info hidden" id="receiveFileInfo"></div>
      
      <div class="sas-code hidden" id="receiverSAS">
        <strong>Security Code:</strong> <span id="receiverSASCode">—</span>
        <div class="key-status" id="receiverKeyStatus"></div>
        <br><small>Verify this code matches the sender's code before accepting</small>
      </div>
      
      <div class="action-buttons">
        <button class="action-btn primary" id="acceptBtn" disabled>
          <i class="fas fa-check"></i> Accept & Receive
        </button>
        <button class="action-btn secondary" id="rejectBtn">
          <i class="fas fa-times"></i> Reject
        </button>
      </div>
      
      <div class="progress-container hidden" id="receiveProgress">
        <div class="progress-bar">
          <div class="progress-fill" id="receiveProgressFill"></div>
        </div>
        <div class="stats">
          <div class="stat-item" id="receiveRate">0 MB/s</div>
          <div class="stat-item" id="receiveGot">0 MB received</div>
        </div>
      </div>
      
      <div class="action-buttons hidden" id="saveButtons">
        <button class="action-btn primary" id="saveAsBtn">
          <i class="fas fa-save"></i> Save As...
        </button>
      </div>
    </div>
  </div>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-section">
          <h4>Quick Links</h4>
          <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="about.html">About</a></li>
            <li><a href="software.html">Software</a></li>
            <li><a href="contact.html">Contact</a></li>
          </ul>
        </div>
        <div class="footer-section">
          <h4>Connect With Us</h4>
          <div class="social-links">
            <a href="https://www.linkedin.com/in/blake-zimmerman-a59575342/" class="social-link" title="LinkedIn" target="_blank" rel="noopener">
              <i class="fab fa-linkedin"></i>
              <span>LinkedIn</span>
            </a>
            <a href="https://github.com/AInsiders" class="social-link" title="GitHub" target="_blank" rel="noopener">
              <i class="fab fa-github"></i>
              <span>GitHub</span>
            </a>
            <a href="https://www.youtube.com/@A.Insiders01" class="social-link" title="YouTube" target="_blank" rel="noopener">
              <i class="fab fa-youtube"></i>
              <span>YouTube</span>
            </a>
            <a href="https://discord.gg/Y4kCtaBZFM" class="social-link" title="Discord" target="_blank" rel="noopener">
              <i class="fab fa-discord"></i>
              <span>Discord</span>
            </a>
          </div>
        </div>
      </div>
      <div class="footer-bottom">
        <p>&copy; 2024 A.Insiders Network. All rights reserved.</p>
        <div class="footer-links">
          <a href="privacy-policy.html">Privacy Policy</a>
          <a href="terms-of-service.html">Terms of Service</a>
          <a href="cookie-policy.html">Cookie Policy</a>
        </div>
      </div>
    </div>
  </footer>

  </div> <!-- End of website-content -->

  <!-- Essential Scripts -->
  <script src="shared-loader.js"></script>
  <script src="mobile-nav.js"></script>
  <script src="sphere-loader.js"></script>
  
  <!-- File Transfer Logic -->
  <script>
    // Configuration - Pure P2P with public STUN/TURN servers
    const ICE_SERVERS = [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' },
      { urls: 'stun:stun3.l.google.com:19302' },
      { urls: 'stun:stun4.l.google.com:19302' },
      // Add TURN servers for NAT traversal
      {
        urls: 'turn:openrelay.metered.ca:80',
        username: 'openrelayproject',
        credential: 'openrelayproject'
      },
      {
        urls: 'turn:openrelay.metered.ca:443',
        username: 'openrelayproject',
        credential: 'openrelayproject'
      },
      {
        urls: 'turn:openrelay.metered.ca:443?transport=tcp',
        username: 'openrelayproject',
        credential: 'openrelayproject'
      }
    ];
    const CHUNK_SIZE = 256 * 1024; // 256 KiB
    const DC_BUF_HIGH = 8 * 1024 * 1024;  // 8 MB
    const DC_BUF_LOW  = 2 * 1024 * 1024;  // 2 MB

    // State variables for pure P2P
    let pc, dc;
    let isSender = null;
    let roomCode = '';
    let sessionKey = null;
    let sasCode = '—';
    let receiverAccepted = false;
    let sendReader = null;
    let fileRef = null;
    let totalSent = 0, totalRecv = 0, fileSize = 0;
    let writable = null;
    let receivedChunks = 0;
    let recvFileHandle = null;
    let recvFileName = 'received.bin';
    
    // Keypair system with expiration
    let keyPair = null;
    let keyExpiration = null;
    let keyExpirationTimer = null;
    let transferStartTime = null;
    
    // P2P Connection state
    let connectionState = 'disconnected';
    let offerData = null;
    let answerData = null;
    let iceCandidates = [];

    // UI Elements
    const $ = sel => document.querySelector(sel);

    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
        console.log('File transfer tool loaded!');
        console.log('Checking UI elements...');
        
        // Debug: Check if elements exist
        const elements = [
            'requestPermissionsBtn',
            'senderBtn', 
            'receiverBtn',
            'roomCode',
            'generateRoomBtn',
            'connectBtn',
            'connectionStatus',
            'permissionStatus'
        ];
        
        elements.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                console.log(`✓ Element found: ${id}`);
            } else {
                console.error(`✗ Element missing: ${id}`);
            }
        });
        
        initializeFileTransfer();
    });

    function initializeFileTransfer() {
        console.log('Initializing file transfer...');
        
        // File system permissions
        $('#requestPermissionsBtn').addEventListener('click', async () => {
            console.log('Requesting file permissions...');
            const permissionStatus = $('#permissionStatus');
            permissionStatus.className = 'status-indicator connecting';
            permissionStatus.innerHTML = '<i class="fas fa-circle"></i><span>Requesting permissions...</span>';
            
            try {
                const granted = await requestInitialPermissions();
                if (granted) {
                    permissionStatus.className = 'status-indicator connected';
                    permissionStatus.innerHTML = '<i class="fas fa-circle"></i><span>File access granted</span>';
                    $('#requestPermissionsBtn').textContent = '✓ Permissions Granted';
                    $('#requestPermissionsBtn').disabled = true;
                } else {
                    permissionStatus.className = 'status-indicator connected';
                    permissionStatus.innerHTML = '<i class="fas fa-circle"></i><span>Using fallback file access</span>';
                    $('#requestPermissionsBtn').textContent = '✓ Fallback Mode';
                    $('#requestPermissionsBtn').disabled = true;
                }
            } catch (error) {
                console.error('Permission request failed:', error);
                permissionStatus.className = 'status-indicator connected';
                permissionStatus.innerHTML = '<i class="fas fa-circle"></i><span>Using fallback file access</span>';
                $('#requestPermissionsBtn').textContent = '✓ Fallback Mode';
                $('#requestPermissionsBtn').disabled = true;
            }
        });
        
        // Role selection
        $('#senderBtn').addEventListener('click', () => {
            console.log('Sender button clicked');
            selectRole(true);
        });
        $('#receiverBtn').addEventListener('click', () => {
            console.log('Receiver button clicked');
            selectRole(false);
        });
        
        // Connection
        $('#connectBtn').addEventListener('click', connectToRoom);
        
        // Generate new room code
        $('#generateRoomBtn').addEventListener('click', () => {
            const newCode = generateRoomCode();
            $('#roomCode').value = newCode;
            updateConnectionStatus(`New room code generated: ${newCode}`, 'connecting');
        });
        
        // File handling
        $('#fileInput').addEventListener('change', handleFileSelect);
        
        // Drag and drop
        setupDragAndDrop();
        
        // Transfer actions
        $('#startSendBtn').addEventListener('click', startSending);
        $('#acceptBtn').addEventListener('click', acceptFile);
        $('#rejectBtn').addEventListener('click', rejectFile);
        $('#saveAsBtn').addEventListener('click', saveFile);
        
                 // Connection data handling
         $('#copyDataBtn').addEventListener('click', copyConnectionData);
         $('#processDataBtn').addEventListener('click', processReceivedData);
        
        console.log('File transfer initialized');
    }
    
         // Pure P2P Connection Functions
     async function startP2PConnection() {
         try {
             updateConnectionStatus('Creating P2P connection...', 'connecting');
             
             // Create peer connection
             pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
             
             // Set up event handlers
             pc.onicecandidate = handleIceCandidate;
             pc.onconnectionstatechange = handleConnectionStateChange;
             pc.oniceconnectionstatechange = handleIceConnectionStateChange;
             
             if (isSender) {
                 // Create data channel for sender
                 dc = pc.createDataChannel('file', { ordered: true });
                 setupDataChannel();
                 
                 // Create and set local description
                 const offer = await pc.createOffer();
                 await pc.setLocalDescription(offer);
                 
                 // Wait for ICE gathering to complete
                 await waitForIceGathering();
                 
                 // Generate connection data
                 offerData = {
                     type: 'offer',
                     sdp: pc.localDescription.sdp,
                     iceCandidates: iceCandidates
                 };
                 
                 // Display connection data
                 displayConnectionData(offerData);
                 
             } else {
                 // Set up data channel handler for receiver
                 pc.ondatachannel = (event) => {
                     dc = event.channel;
                     setupDataChannel();
                 };
             }
             
         } catch (error) {
             console.error('Failed to start P2P connection:', error);
             updateConnectionStatus('Failed to create connection', 'error');
             handleError(error, 'P2P Connection');
         }
     }
     
     function handleIceCandidate(event) {
         if (event.candidate) {
             iceCandidates.push(event.candidate);
         }
     }
     
     function handleConnectionStateChange() {
         console.log('Connection state:', pc.connectionState);
         if (pc.connectionState === 'connected') {
             updateConnectionStatus('P2P connection established!', 'connected');
             showNotification('Direct P2P connection established!', 'success');
         } else if (pc.connectionState === 'failed') {
             updateConnectionStatus('Connection failed', 'error');
         }
     }
     
     function handleIceConnectionStateChange() {
         console.log('ICE connection state:', pc.iceConnectionState);
     }
     
     async function waitForIceGathering() {
         return new Promise((resolve) => {
             if (pc.iceGatheringState === 'complete') {
                 resolve();
             } else {
                 pc.onicecandidate = (event) => {
                     if (event.candidate) {
                         iceCandidates.push(event.candidate);
                     } else {
                         // ICE gathering complete
                         resolve();
                     }
                 };
             }
         });
     }
     
     function displayConnectionData(data) {
         const connectionDataText = JSON.stringify(data, null, 2);
         $('#connectionDataText').value = connectionDataText;
         $('#connectionData').classList.remove('hidden');
         updateConnectionStatus('Connection data ready - share with other user', 'connecting');
     }
     
     async function copyConnectionData() {
         const dataText = $('#connectionDataText').value;
         try {
             await navigator.clipboard.writeText(dataText);
             showNotification('Connection data copied to clipboard!', 'success');
         } catch (error) {
             showNotification('Failed to copy data', 'error');
         }
     }
     
     async function processReceivedData() {
         try {
             const receivedText = $('#receivedDataText').value.trim();
             if (!receivedText) {
                 showNotification('Please paste connection data first', 'error');
                 return;
             }
             
             const receivedData = JSON.parse(receivedText);
             
             if (receivedData.type === 'offer') {
                 // Process offer from sender
                 await processOffer(receivedData);
             } else if (receivedData.type === 'answer') {
                 // Process answer from receiver
                 await processAnswer(receivedData);
             } else {
                 throw new Error('Invalid connection data format');
             }
             
         } catch (error) {
             console.error('Failed to process received data:', error);
             showNotification('Invalid connection data', 'error');
         }
     }
     
     async function processOffer(offerData) {
         try {
             // Set remote description
             await pc.setRemoteDescription({
                 type: 'offer',
                 sdp: offerData.sdp
             });
             
             // Add ICE candidates
             for (const candidate of offerData.iceCandidates || []) {
                 await pc.addIceCandidate(candidate);
             }
             
             // Create answer
             const answer = await pc.createAnswer();
             await pc.setLocalDescription(answer);
             
             // Wait for ICE gathering
             await waitForIceGathering();
             
             // Generate answer data
             answerData = {
                 type: 'answer',
                 sdp: pc.localDescription.sdp,
                 iceCandidates: iceCandidates
             };
             
             // Display answer data
             displayConnectionData(answerData);
             
         } catch (error) {
             console.error('Failed to process offer:', error);
             throw error;
         }
     }
     
     async function processAnswer(answerData) {
         try {
             // Set remote description
             await pc.setRemoteDescription({
                 type: 'answer',
                 sdp: answerData.sdp
             });
             
             // Add ICE candidates
             for (const candidate of answerData.iceCandidates || []) {
                 await pc.addIceCandidate(candidate);
             }
             
         } catch (error) {
             console.error('Failed to process answer:', error);
             throw error;
         }
     }

    function selectRole(sender) {
        console.log('selectRole called with:', sender);
        isSender = sender;
        
        // Remove active class from all role buttons
        const allRoleBtns = document.querySelectorAll('.role-btn');
        console.log('Found role buttons:', allRoleBtns.length);
        allRoleBtns.forEach(btn => {
            btn.classList.remove('active');
            console.log('Removed active class from:', btn.id);
        });
        
        if (sender) {
            const senderBtn = document.getElementById('senderBtn');
            if (senderBtn) {
                senderBtn.classList.add('active');
                console.log('Added active class to sender button');
            } else {
                console.error('Sender button not found!');
            }
            
            // Generate a room code for sender
            const roomCode = generateRoomCode();
            const roomInput = document.getElementById('roomCode');
            if (roomInput) {
                roomInput.value = roomCode;
                console.log('Set room code:', roomCode);
            }
            
            const generateBtn = document.getElementById('generateRoomBtn');
            if (generateBtn) {
                generateBtn.style.display = 'block';
                console.log('Showed generate room button');
            }
            
            updateConnectionStatus(`Role selected: Sender - Room code: ${roomCode}`, 'connecting');
        } else {
            const receiverBtn = document.getElementById('receiverBtn');
            if (receiverBtn) {
                receiverBtn.classList.add('active');
                console.log('Added active class to receiver button');
            } else {
                console.error('Receiver button not found!');
            }
            
            const roomInput = document.getElementById('roomCode');
            if (roomInput) {
                roomInput.value = '';
                console.log('Cleared room code input');
            }
            
            const generateBtn = document.getElementById('generateRoomBtn');
            if (generateBtn) {
                generateBtn.style.display = 'none';
                console.log('Hidden generate room button');
            }
            
            updateConnectionStatus(`Role selected: Receiver - Enter room code from sender`, 'connecting');
        }
        console.log('Role selection complete:', sender ? 'Sender' : 'Receiver');
    }

    function generateRoomCode() {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        let result = '';
        for (let i = 0; i < 6; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

         async function connectToRoom() {
         roomCode = $('#roomCode').value.trim();
         if (!roomCode) {
             showNotification('Please enter a room code', 'error');
             return;
         }
         
         if (isSender === null) {
             showNotification('Please select your role first', 'error');
             return;
         }

         // Reset connection state
         connectionState = 'connecting';
         iceCandidates = [];
         
         // Start P2P connection
         await startP2PConnection();
     }

    function updateConnectionStatus(message, type) {
        const status = $('#connectionStatus');
        status.className = `status-indicator ${type}`;
        
        let icon = '<i class="fas fa-circle"></i>';
        if (type === 'connecting') {
            icon = '<div class="loading-spinner"></div>';
        } else if (type === 'connected') {
            icon = '<div class="success-checkmark"></div>';
        } else if (type === 'error') {
            icon = '<div class="error-x"></div>';
        }
        
        status.innerHTML = `${icon}<span>${message}</span>`;
    }

         async function setupPeerConnection() {
         // This function is now handled by startP2PConnection()
         console.log('setupPeerConnection called - using new P2P system');
     }

         function setupDataChannel() {
         dc.binaryType = 'arraybuffer';
         dc.bufferedAmountLowThreshold = DC_BUF_LOW;
         
         dc.onopen = async () => {
             console.log('Data channel opened');
             updateConnectionStatus('Data channel open - establishing secure connection', 'connecting');
             
             try {
                 await deriveSessionKey();
                 updateSAS();
                 
                 if (isSender) {
                     showSenderUI();
                     updateConnectionStatus('Ready to send files', 'connected');
                 } else {
                     showReceiverUI();
                     updateConnectionStatus('Ready to receive files', 'connected');
                 }
                 
                 showNotification('Secure P2P connection established!', 'success');
             } catch (error) {
                 console.error('Failed to setup secure connection:', error);
                 updateConnectionStatus('Failed to establish secure connection', 'error');
             }
         };
         
         dc.onbufferedamountlow = () => sendPump();
         dc.onmessage = handleDataChannelMessage;
         dc.onclose = () => {
             updateConnectionStatus('Data channel closed', 'error');
             showNotification('Connection lost', 'error');
         };
         
         dc.onerror = (error) => {
             console.error('Data channel error:', error);
             updateConnectionStatus('Data channel error', 'error');
         };
     }

    // Send pump function for handling backpressure
    function sendPump() {
        if (sendReader && !sendReader.closed) {
            if (!transferStartTime) {
                transferStartTime = performance.now();
            }
            
            sendReader.read().then(({ value, done }) => {
                if (done) {
                    dc.send(JSON.stringify({ type: 'eof' }));
                    updateConnectionStatus('Transfer complete', 'connected');
                    return;
                }
                
                const chunk = value.buffer ? value : new Uint8Array(value);
                sendChunk(chunk);
                
                totalSent += chunk.byteLength;
                updateSendProgress(totalSent, fileRef.size, transferStartTime);
                
                // Continue pumping if buffer is low
                if (dc.bufferedAmount <= DC_BUF_LOW) {
                    sendPump();
                }
            }).catch(error => {
                console.error('Error in send pump:', error);
                updateConnectionStatus('Transfer error', 'error');
            });
        }
    }

    async function deriveSessionKey() {
        try {
            // Generate ECDH keypair for secure key exchange
            keyPair = await crypto.subtle.generateKey(
                {
                    name: 'ECDH',
                    namedCurve: 'P-256'
                },
                true,
                ['deriveKey', 'deriveBits']
            );
            
            // Generate AES-GCM session key
            sessionKey = await crypto.subtle.generateKey(
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
            
            // Set key expiration (5 minutes)
            keyExpiration = Date.now() + (5 * 60 * 1000);
            
            // Clear any existing timer
            if (keyExpirationTimer) {
                clearTimeout(keyExpirationTimer);
            }
            
            // Set timer to expire keys
            keyExpirationTimer = setTimeout(() => {
                expireKeys();
            }, 5 * 60 * 1000);
            
            // Generate SAS code from public key
            const publicKeyBuffer = await crypto.subtle.exportKey('raw', keyPair.publicKey);
            const hash = await crypto.subtle.digest('SHA-256', publicKeyBuffer);
            const hashArray = new Uint8Array(hash);
            sasCode = toSAS(hashArray.slice(0, 4));
            
            console.log('Session key derived, expires in 5 minutes');
            updateKeyStatus();
            
        } catch (error) {
            console.error('Failed to derive session key:', error);
            throw error;
        }
    }
    
    function expireKeys() {
        sessionKey = null;
        keyPair = null;
        keyExpiration = null;
        sasCode = 'EXPIRED';
        
        updateConnectionStatus('Session expired - please reconnect', 'error');
        updateKeyStatus();
        
        console.log('Session keys expired');
    }
    
    function updateKeyStatus() {
        if (keyExpiration) {
            const timeLeft = Math.max(0, Math.floor((keyExpiration - Date.now()) / 1000));
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            
            const statusElement = $('#keyStatus');
            if (statusElement) {
                statusElement.textContent = `Key expires in: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                if (timeLeft < 60) {
                    statusElement.style.color = '#ff6b6b';
                } else if (timeLeft < 180) {
                    statusElement.style.color = '#ffd93d';
                } else {
                    statusElement.style.color = '#6bcf7f';
                }
            }
        }
    }

    function toSAS(bytes) {
        const words = ['acorn','amber','anchor','arrow','atlas','aurora','badge','bamboo','bison','blaze','bolt','canyon','cedar','comet','coral','coyote','crimson','ember','falcon','fjord','flint','galaxy','harbor','indigo','ivory','jade','jet','lagoon','linen','maple','nebula','onyx','opal','orbit','pearl','pine','quartz','raven','reef','sable','sage','sierra','spruce','tango','topaz','umbra','velvet','violet','willow','yarrow','zephyr'];
        const i1 = bytes[0] % words.length;
        const i2 = bytes[1] % words.length;
        const i3 = bytes[2] % words.length;
        const i4 = bytes[3] % words.length;
        return `${words[i1]} ${words[i2]} ${words[i3]} ${words[i4]}`;
    }

    function updateSAS() {
        if (isSender) {
            $('#senderSAS').classList.remove('hidden');
            $('#senderSASCode').textContent = sasCode;
            $('#senderKeyStatus').id = 'keyStatus';
        } else {
            $('#receiverSAS').classList.remove('hidden');
            $('#receiverSASCode').textContent = sasCode;
            $('#receiverKeyStatus').id = 'keyStatus';
        }
        
        // Start key status updates
        updateKeyStatus();
        setInterval(updateKeyStatus, 1000);
    }

    function showSenderUI() {
        $('#senderUI').classList.add('active');
    }

    function showReceiverUI() {
        $('#receiverUI').classList.add('active');
    }

    function setupDragAndDrop() {
        const dropZone = $('#fileDropZone');
        
        // Prevent default drag behaviors
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        // Highlight drop zone when item is dragged over it
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, unhighlight, false);
        });
        
        function highlight(e) {
            dropZone.classList.add('dragover');
        }
        
        function unhighlight(e) {
            dropZone.classList.remove('dragover');
        }
        
        // Handle dropped files
        dropZone.addEventListener('drop', handleDrop, false);
        
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length > 0) {
                console.log('File dropped:', files[0].name);
                handleFile(files[0]);
            }
        }
        
        // Also handle click to open file dialog with permission request
        dropZone.addEventListener('click', async () => {
            // Try to use File System Access API first for better permissions
            if ('showOpenFilePicker' in window) {
                try {
                    const options = {
                        multiple: false,
                        types: [{
                            description: 'All Files',
                            accept: {
                                '*/*': ['.*']
                            }
                        }]
                    };
                    
                    const [fileHandle] = await window.showOpenFilePicker(options);
                    
                    // Request read permission
                    const permission = await fileHandle.requestPermission({ mode: 'read' });
                    if (permission === 'granted') {
                        const file = await fileHandle.getFile();
                        console.log('File selected with permission:', file.name);
                        handleFile(file);
                    } else {
                        console.log('File read permission denied');
                        // Fallback to traditional file input
                        $('#fileInput').click();
                    }
                } catch (e) {
                    console.log('File System Access API failed, using fallback:', e.message);
                    // Fallback to traditional file input
                    $('#fileInput').click();
                }
            } else {
                // Fallback to traditional file input
                $('#fileInput').click();
            }
        });
    }

    function handleFileSelect(e) {
        const file = e.target.files[0];
        if (file) {
            console.log('File selected via input:', file.name, 'Size:', formatBytes(file.size));
            handleFile(file);
        } else {
            console.log('No file selected');
        }
    }

    function handleFile(file) {
        fileRef = file;
        const fileInfo = $('#fileInfo');
        fileInfo.classList.remove('hidden');
        fileInfo.innerHTML = `
            <strong>Selected File:</strong> ${file.name}<br>
            <strong>Size:</strong> ${formatBytes(file.size)}<br>
            <strong>Type:</strong> ${file.type || 'Unknown'}
        `;
        $('#startSendBtn').disabled = false;
        console.log('File handled:', file.name, 'Size:', formatBytes(file.size));
    }

    function formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    async function startSending() {
        if (!fileRef) return;
        
        $('#startSendBtn').disabled = true;
        $('#sendProgress').classList.remove('hidden');
        
        // Send file metadata
        const meta = {
            name: fileRef.name,
            size: fileRef.size,
            type: fileRef.type
        };
        
        dc.send(JSON.stringify({ type: 'meta', meta }));
        
        // Start file transfer
        const reader = fileRef.stream().getReader();
        sendReader = reader;
        totalSent = 0;
        transferStartTime = null; // Reset transfer start time
        
        // Start the send pump
        sendPump();
    }

    async function sendChunk(chunk) {
        if (dc.bufferedAmount > DC_BUF_HIGH) {
            await new Promise(resolve => {
                dc.addEventListener('bufferedamountlow', resolve, { once: true });
            });
        }
        
        // Check if keys are still valid
        if (!sessionKey || keyExpiration < Date.now()) {
            console.error('Session key expired during transfer');
            updateConnectionStatus('Session expired during transfer', 'error');
            return;
        }
        
        // Encrypt chunk
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encrypted = await crypto.subtle.encrypt(
            { name: 'AES-GCM', iv },
            sessionKey,
            chunk
        );
        
        dc.send(encrypted);
    }

    function updateSendProgress(sent, total, startTime) {
        const progress = (sent / total) * 100;
        $('#sendProgressFill').style.width = progress + '%';
        
        const elapsed = (performance.now() - startTime) / 1000;
        const rate = elapsed > 0 ? sent / (1024 * 1024 * elapsed) : 0;
        
        $('#sendRate').textContent = rate.toFixed(2) + ' MB/s';
        $('#sendSent').textContent = formatBytes(sent) + ' sent';
    }

         // WebSocket message handling is no longer needed for pure P2P
     function handleWebSocketMessage(ev) {
         console.log('WebSocket message handling disabled - using pure P2P');
     }

    function handleDataChannelMessage(ev) {
        if (typeof ev.data === 'string') {
            try {
                const msg = JSON.parse(ev.data);
                handleControlMessage(msg);
            } catch (e) {
                // Ignore invalid JSON
            }
        } else {
            handleBinaryMessage(ev.data);
        }
    }

    function handleControlMessage(msg) {
        if (msg.type === 'meta') {
            showIncomingFile(msg.meta);
        } else if (msg.type === 'accepted') {
            if (isSender) {
                updateConnectionStatus('Receiver accepted, starting transfer...', 'connected');
            }
        } else if (msg.type === 'eof') {
            if (!isSender) {
                finishReceiving();
            }
        }
    }

    function showIncomingFile(meta) {
        const fileInfo = $('#receiveFileInfo');
        fileInfo.classList.remove('hidden');
        fileInfo.innerHTML = `
            <strong>Incoming File:</strong> ${meta.name}<br>
            <strong>Size:</strong> ${formatBytes(meta.size)}<br>
            <strong>Type:</strong> ${meta.type || 'Unknown'}
        `;
        
        recvFileName = meta.name;
        fileSize = meta.size;
        $('#acceptBtn').disabled = false;
    }

    async function acceptFile() {
        $('#acceptBtn').disabled = true;
        $('#receiveProgress').classList.remove('hidden');
        
        // Request file system permissions and prepare file save
        try {
            if ('showSaveFilePicker' in window) {
                // Request permission to save files
                const options = {
                    suggestedName: recvFileName,
                    types: [{
                        description: 'All Files',
                        accept: {
                            '*/*': ['.*']
                        }
                    }]
                };
                
                recvFileHandle = await window.showSaveFilePicker(options);
                
                // Request write permission
                const permission = await recvFileHandle.requestPermission({ mode: 'readwrite' });
                if (permission === 'granted') {
                    writable = await recvFileHandle.createWritable();
                    console.log('File permission granted, ready to receive');
                } else {
                    throw new Error('File write permission denied');
                }
            } else {
                console.log('File System Access API not available, using fallback');
            }
        } catch (e) {
            console.log('File permission request failed:', e.message);
            // Continue with fallback method
        }
        
        dc.send(JSON.stringify({ type: 'accepted' }));
        updateConnectionStatus('Receiving file...', 'connected');
    }

    function rejectFile() {
        updateConnectionStatus('File rejected', 'error');
    }

    async function handleBinaryMessage(data) {
        if (!isSender) {
            // Check if keys are still valid
            if (!sessionKey || keyExpiration < Date.now()) {
                console.error('Session key expired during receive');
                updateConnectionStatus('Session expired during receive', 'error');
                return;
            }
            
            // Decrypt and save chunk
            try {
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: new Uint8Array(data.slice(0, 12)) },
                    sessionKey,
                    data.slice(12)
                );
                
                totalRecv += decrypted.byteLength;
                updateReceiveProgress(totalRecv, fileSize);
                
                if (writable) {
                    await writable.write(new Uint8Array(decrypted));
                } else {
                    // Fallback to memory (not recommended for large files)
                    window.memChunks = window.memChunks || [];
                    window.memChunks.push(new Uint8Array(decrypted));
                }
            } catch (e) {
                console.error('Decryption failed:', e);
            }
        }
    }

    function updateReceiveProgress(received, total) {
        const progress = (received / total) * 100;
        $('#receiveProgressFill').style.width = progress + '%';
        
        $('#receiveGot').textContent = formatBytes(received) + ' received';
    }

    async function finishReceiving() {
        if (writable) {
            await writable.close();
        } else if (window.memChunks) {
            // Fallback: create blob and download
            const blob = new Blob(window.memChunks);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = recvFileName;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        $('#saveButtons').classList.remove('hidden');
        updateConnectionStatus('File received successfully', 'connected');
    }

    async function saveFile() {
        if (recvFileHandle) {
            // File already saved via File System Access API
            return;
        }
        
        // Trigger download if not already saved
        if (window.memChunks) {
            const blob = new Blob(window.memChunks);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = recvFileName;
            a.click();
            URL.revokeObjectURL(url);
        }
    }

    // Function to check and request file system permissions
    async function checkFilePermissions() {
        if ('showDirectoryPicker' in window) {
            try {
                const dirHandle = await window.showDirectoryPicker();
                const permission = await dirHandle.requestPermission({ mode: 'readwrite' });
                if (permission === 'granted') {
                    console.log('Directory permission granted');
                    return dirHandle;
                }
            } catch (e) {
                console.log('Directory permission request failed:', e.message);
            }
        }
        return null;
    }

    // Function to request file system permissions on page load
    async function requestInitialPermissions() {
        console.log('Requesting initial file system permissions...');
        
        // Check if browser supports File System Access API
        if ('showDirectoryPicker' in window) {
            try {
                const dirHandle = await checkFilePermissions();
                if (dirHandle) {
                    console.log('File system permissions granted');
                    return true;
                }
            } catch (e) {
                console.log('File system permission request failed:', e.message);
                // Don't throw error, just return false to use fallback
                return false;
            }
        } else {
            console.log('File System Access API not supported, using fallback methods');
            return false;
        }
        return false;
    }

    // Modern Notification System
    function showNotification(message, type = 'info', duration = 5000) {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.innerHTML = `
            <div class="notification-content">
                <div class="notification-icon">
                    ${type === 'success' ? '<div class="success-checkmark"></div>' : 
                      type === 'error' ? '<div class="error-x"></div>' : 
                      '<i class="fas fa-info-circle"></i>'}
                </div>
                <span>${message}</span>
                <button class="notification-close" onclick="this.parentElement.parentElement.remove()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        // Animate in
        setTimeout(() => notification.classList.add('show'), 100);
        
        // Auto remove
        if (duration > 0) {
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, duration);
        }
    }
    
    // Enhanced error handling
    function handleError(error, context = '') {
        console.error(`Error in ${context}:`, error);
        showNotification(`Error: ${error.message}`, 'error');
    }
    
    // Export for potential use in other scripts
    window.fileTransfer = {
        initialize: initializeFileTransfer,
        requestPermissions: requestInitialPermissions,
        showNotification: showNotification,
        handleError: handleError
    };
  </script>
  
  <script src="security-enhancement.js"></script>
</body>
</html>
