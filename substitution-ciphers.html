<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Substitution Ciphers - A.Insiders Tools</title>
    
    <!-- Favicon Setup -->
    <link rel="icon" type="image/png" href="ainsiders-logo.png" id="main-favicon">
    <link rel="apple-touch-icon" href="ainsiders-logo.png">
    <meta name="description" content="Advanced substitution cipher tools including Caesar, ROT13, Atbash, Playfair, and more. Free, secure, and browser-based encryption tools.">
    <meta name="keywords" content="substitution ciphers, caesar cipher, rot13, atbash, playfair cipher, encryption tools, A.Insiders tools">
    
    <!-- Security Headers -->
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=()">
    
    <!-- Enhanced Cache Control Headers for Cloudflare -->
    <meta http-equiv="Cache-Control" content="public, max-age=31536000, immutable, stale-while-revalidate=86400">
    <meta http-equiv="Expires" content="31536000">
    <meta http-equiv="ETag" content="substitution-ciphers-v1.0">
    <meta http-equiv="Last-Modified" content="2023-12-31T00:00:00Z">
    
    <!-- Optimized Asset Caching System with Cloudflare Headers -->
    <link rel="stylesheet" href="brain-styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    
    <!-- Preload critical assets with Cloudflare caching -->
    <link rel="preload" href="brain-script.js?v=1.0" as="script" crossorigin="anonymous">
    <link rel="preload" href="shared-loader.js?v=1.0" as="script" crossorigin="anonymous">
    <link rel="preload" href="mobile-nav.js?v=1.0" as="script" crossorigin="anonymous">
    <link rel="preload" href="sphere-loader.js?v=1.0" as="script" crossorigin="anonymous">
    <link rel="preload" href="ainsiders-logo.png?v=1.0" as="image" type="image/png">
    <link rel="preload" href="logo.svg?v=1.0" as="image" type="image/svg+xml">
    
    <!-- Cache Manager and Asset Preloader with Cloudflare caching -->
    <script src="browser-cache-manager.js"></script>
    <script src="asset-preloader.js"></script>
    
    <!-- Optimized Background System -->
    <script src="brain-script.js"></script>
    
    <!-- Font Awesome with CDN and Fallback -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer">
    
    <!-- Favicon Animation Script -->
    <script src="favicon-animation.js"></script>
    
    <style>
        /* Substitution Ciphers Specific Styles */
        .cipher-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            background: rgba(0, 0, 0, 0.25);
            border-radius: 20px;
            box-shadow: var(--shadow-dark);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border: 1px solid rgba(0, 102, 255, 0.2);
            position: relative;
            z-index: 1;
        }

        /* Neural Background Canvas - Full Page Coverage */
        #aiCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 1;
            pointer-events: none;
        }

        /* Page Hero Section with Neural Background */
        .page-hero {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(10, 10, 10, 0.9));
            padding: 2rem 0;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .hero-content {
            position: relative;
            z-index: 2;
            max-width: 800px;
        }

        .hero-title {
            font-size: 3.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #00ff88, #00ccff, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }

        .hero-subtitle {
            font-size: 1.25rem;
            color: var(--text-secondary);
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        /* Cipher Grid Layout */
        .cipher-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
            margin-top: 2rem;
        }

        .cipher-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 1.5rem;
            border: 1px solid rgba(0, 102, 255, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .cipher-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 102, 255, 0.2);
            border-color: rgba(0, 102, 255, 0.4);
        }

        .cipher-header {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(0, 102, 255, 0.2);
        }

        .cipher-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #00ff88, #00ccff);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 1rem;
            font-size: 1.2rem;
            color: #000;
        }

        .cipher-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .cipher-input {
            width: 100%;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 102, 255, 0.3);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .cipher-input:focus {
            outline: none;
            border-color: #00ccff;
            box-shadow: 0 0 0 3px rgba(0, 204, 255, 0.1);
        }

        .cipher-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        /* Key Input for ciphers that need it */
        .key-input {
            width: 100%;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 102, 255, 0.3);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        /* Binary-specific styling */
        .binary-input {
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
        }

        .hex-input {
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
        }

        /* Results Display */
        .results-container {
            margin-top: 2rem;
            padding: 1.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            border: 1px solid rgba(0, 102, 255, 0.2);
        }

        .results-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
        }

        .results-title i {
            margin-right: 0.5rem;
            color: #00ff88;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            border: 1px solid rgba(0, 102, 255, 0.1);
        }

        .result-label {
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .result-value {
            font-family: 'Courier New', monospace;
            font-weight: 600;
            color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .result-value:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            font-size: 0.9rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00ff88, #00ccff);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
        }

        .btn-secondary {
            background: rgba(0, 102, 255, 0.2);
            color: var(--text-primary);
            border: 1px solid rgba(0, 102, 255, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(0, 102, 255, 0.3);
            border-color: rgba(0, 102, 255, 0.5);
        }

        /* Binary Visualization */
        .binary-visualization {
            margin-top: 2rem;
            padding: 1.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            border: 1px solid rgba(0, 102, 255, 0.2);
        }

        .binary-bits {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .bit {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .bit-1 {
            background: linear-gradient(135deg, #00ff88, #00ccff);
            color: #000;
        }

        .bit-0 {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Error Messages */
        .error-message {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid rgba(255, 107, 107, 0.3);
            padding: 0.75rem;
            border-radius: 8px;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        /* Success Messages */
        .success-message {
            color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            padding: 0.75rem;
            border-radius: 8px;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .hero-title {
                font-size: 2.5rem;
            }
            
            .converter-grid {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
            
            .action-buttons {
                flex-direction: column;
            }
            
            .btn {
                justify-content: center;
            }
            
            .binary-bits {
                gap: 0.15rem;
            }
            
            .bit {
                width: 25px;
                height: 25px;
                font-size: 0.7rem;
            }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 255, 136, 0.3);
            border-radius: 50%;
            border-top-color: #00ff88;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Copy Animation */
        .copy-animation {
            animation: copyPulse 0.5s ease-in-out;
        }

        @keyframes copyPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <!-- Neural Background Canvas -->
    <canvas id="aiCanvas"></canvas>

    <!-- Page Hero Section -->
    <section class="page-hero">
        <div class="hero-content">
            <h1 class="hero-title">
                <i class="fas fa-key"></i>
                Substitution Ciphers
            </h1>
            <p class="hero-subtitle">
                Advanced encryption tools featuring Caesar, ROT13, Atbash, Playfair, and more classic substitution ciphers with real-time encoding and decoding
            </p>
        </div>
    </section>

    <!-- Main Cipher Container -->
    <div class="cipher-container">
        <!-- Cipher Grid -->
        <div class="cipher-grid">
            <!-- Caesar Cipher -->
            <div class="cipher-card">
                <div class="cipher-header">
                    <div class="cipher-icon">
                        <i class="fas fa-shift"></i>
                    </div>
                    <div class="cipher-title">Caesar Cipher</div>
                </div>
                <div class="cipher-description">
                    Shift each letter by a fixed number of positions in the alphabet
                </div>
                <div class="input-group">
                    <label class="input-label">Shift Key (1-25)</label>
                    <input type="number" id="caesarKey" class="key-input" placeholder="e.g., 3" min="1" max="25" value="3">
                </div>
                <div class="input-group">
                    <label class="input-label">Text to Encode/Decode</label>
                    <input type="text" id="caesarInput" class="cipher-input" placeholder="e.g., HELLO WORLD">
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="caesarEncode()">
                        <i class="fas fa-lock"></i>
                        Encode
                    </button>
                    <button class="btn btn-primary" onclick="caesarDecode()">
                        <i class="fas fa-unlock"></i>
                        Decode
                    </button>
                    <button class="btn btn-secondary" onclick="clearCipher('caesar')">
                        <i class="fas fa-eraser"></i>
                        Clear
                    </button>
                </div>
                <div class="results-container" id="caesarResults" style="display: none;"></div>
            </div>

            <!-- ROT13 Cipher -->
            <div class="cipher-card">
                <div class="cipher-header">
                    <div class="cipher-icon">
                        <i class="fas fa-rotate"></i>
                    </div>
                    <div class="cipher-title">ROT13</div>
                </div>
                <div class="cipher-description">
                    Rotate each letter by 13 positions (same operation for encode/decode)
                </div>
                <div class="input-group">
                    <label class="input-label">Text to Encode/Decode</label>
                    <input type="text" id="rot13Input" class="cipher-input" placeholder="e.g., HELLO WORLD">
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="rot13Encode()">
                        <i class="fas fa-sync-alt"></i>
                        Encode/Decode
                    </button>
                    <button class="btn btn-secondary" onclick="clearCipher('rot13')">
                        <i class="fas fa-eraser"></i>
                        Clear
                    </button>
                </div>
                <div class="results-container" id="rot13Results" style="display: none;"></div>
            </div>

            <!-- Atbash Cipher -->
            <div class="cipher-card">
                <div class="cipher-header">
                    <div class="cipher-icon">
                        <i class="fas fa-arrows-alt-h"></i>
                    </div>
                    <div class="cipher-title">Atbash Cipher</div>
                </div>
                <div class="cipher-description">
                    Reverse the alphabet (A↔Z, B↔Y, C↔X, etc.)
                </div>
                <div class="input-group">
                    <label class="input-label">Text to Encode/Decode</label>
                    <input type="text" id="atbashInput" class="cipher-input" placeholder="e.g., HELLO WORLD">
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="atbashEncode()">
                        <i class="fas fa-exchange-alt"></i>
                        Encode/Decode
                    </button>
                    <button class="btn btn-secondary" onclick="clearCipher('atbash')">
                        <i class="fas fa-eraser"></i>
                        Clear
                    </button>
                </div>
                <div class="results-container" id="atbashResults" style="display: none;"></div>
            </div>

            <!-- Simple Substitution Cipher -->
            <div class="cipher-card">
                <div class="cipher-header">
                    <div class="cipher-icon">
                        <i class="fas fa-random"></i>
                    </div>
                    <div class="cipher-title">Simple Substitution</div>
                </div>
                <div class="cipher-description">
                    Replace each letter with another letter using a custom key
                </div>
                <div class="input-group">
                    <label class="input-label">Substitution Key (26 letters)</label>
                    <input type="text" id="substitutionKey" class="key-input" placeholder="e.g., QWERTYUIOPASDFGHJKLZXCVBNM" maxlength="26">
                </div>
                <div class="input-group">
                    <label class="input-label">Text to Encode/Decode</label>
                    <input type="text" id="substitutionInput" class="cipher-input" placeholder="e.g., HELLO WORLD">
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="substitutionEncode()">
                        <i class="fas fa-lock"></i>
                        Encode
                    </button>
                    <button class="btn btn-primary" onclick="substitutionDecode()">
                        <i class="fas fa-unlock"></i>
                        Decode
                    </button>
                    <button class="btn btn-secondary" onclick="clearCipher('substitution')">
                        <i class="fas fa-eraser"></i>
                        Clear
                    </button>
                </div>
                <div class="results-container" id="substitutionResults" style="display: none;"></div>
            </div>

            <!-- Keyword Cipher -->
            <div class="cipher-card">
                <div class="cipher-header">
                    <div class="cipher-icon">
                        <i class="fas fa-key"></i>
                    </div>
                    <div class="cipher-title">Keyword Cipher</div>
                </div>
                <div class="cipher-description">
                    Use a keyword to create a custom alphabet
                </div>
                <div class="input-group">
                    <label class="input-label">Keyword</label>
                    <input type="text" id="keywordKey" class="key-input" placeholder="e.g., SECRET" maxlength="26">
                </div>
                <div class="input-group">
                    <label class="input-label">Text to Encode/Decode</label>
                    <input type="text" id="keywordInput" class="cipher-input" placeholder="e.g., HELLO WORLD">
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="keywordEncode()">
                        <i class="fas fa-lock"></i>
                        Encode
                    </button>
                    <button class="btn btn-primary" onclick="keywordDecode()">
                        <i class="fas fa-unlock"></i>
                        Decode
                    </button>
                    <button class="btn btn-secondary" onclick="clearCipher('keyword')">
                        <i class="fas fa-eraser"></i>
                        Clear
                    </button>
                </div>
                <div class="results-container" id="keywordResults" style="display: none;"></div>
            </div>

            <!-- Affine Cipher -->
            <div class="cipher-card">
                <div class="cipher-header">
                    <div class="cipher-icon">
                        <i class="fas fa-function"></i>
                    </div>
                    <div class="cipher-title">Affine Cipher</div>
                </div>
                <div class="cipher-description">
                    Mathematical cipher: E(x) = (ax + b) mod 26
                </div>
                <div class="input-group">
                    <label class="input-label">Multiplier (a) - must be coprime with 26</label>
                    <input type="number" id="affineA" class="key-input" placeholder="e.g., 5" min="1" max="25" value="5">
                </div>
                <div class="input-group">
                    <label class="input-label">Shift (b)</label>
                    <input type="number" id="affineB" class="key-input" placeholder="e.g., 8" min="0" max="25" value="8">
                </div>
                <div class="input-group">
                    <label class="input-label">Text to Encode/Decode</label>
                    <input type="text" id="affineInput" class="cipher-input" placeholder="e.g., HELLO WORLD">
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="affineEncode()">
                        <i class="fas fa-lock"></i>
                        Encode
                    </button>
                    <button class="btn btn-primary" onclick="affineDecode()">
                        <i class="fas fa-unlock"></i>
                        Decode
                    </button>
                    <button class="btn btn-secondary" onclick="clearCipher('affine')">
                        <i class="fas fa-eraser"></i>
                        Clear
                    </button>
                </div>
                <div class="results-container" id="affineResults" style="display: none;"></div>
            </div>

            <!-- Bacon Cipher -->
            <div class="cipher-card">
                <div class="cipher-header">
                    <div class="cipher-icon">
                        <i class="fas fa-bacon"></i>
                    </div>
                    <div class="cipher-title">Bacon Cipher</div>
                </div>
                <div class="cipher-description">
                    Encode text using binary patterns (A=00000, B=00001, etc.)
                </div>
                <div class="input-group">
                    <label class="input-label">Text to Encode/Decode</label>
                    <input type="text" id="baconInput" class="cipher-input" placeholder="e.g., HELLO">
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="baconEncode()">
                        <i class="fas fa-lock"></i>
                        Encode
                    </button>
                    <button class="btn btn-primary" onclick="baconDecode()">
                        <i class="fas fa-unlock"></i>
                        Decode
                    </button>
                    <button class="btn btn-secondary" onclick="clearCipher('bacon')">
                        <i class="fas fa-eraser"></i>
                        Clear
                    </button>
                </div>
                <div class="results-container" id="baconResults" style="display: none;"></div>
            </div>

            <!-- Morse Code -->
            <div class="cipher-card">
                <div class="cipher-header">
                    <div class="cipher-icon">
                        <i class="fas fa-signal"></i>
                    </div>
                    <div class="cipher-title">Morse Code</div>
                </div>
                <div class="cipher-description">
                    Convert text to dots and dashes
                </div>
                <div class="input-group">
                    <label class="input-label">Text to Encode/Decode</label>
                    <input type="text" id="morseInput" class="cipher-input" placeholder="e.g., HELLO WORLD">
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="morseEncode()">
                        <i class="fas fa-lock"></i>
                        Encode
                    </button>
                    <button class="btn btn-primary" onclick="morseDecode()">
                        <i class="fas fa-unlock"></i>
                        Decode
                    </button>
                    <button class="btn btn-secondary" onclick="clearCipher('morse')">
                        <i class="fas fa-eraser"></i>
                        Clear
                    </button>
                </div>
                <div class="results-container" id="morseResults" style="display: none;"></div>
            </div>

            <!-- Pigpen Cipher -->
            <div class="cipher-card">
                <div class="cipher-header">
                    <div class="cipher-icon">
                        <i class="fas fa-draw-polygon"></i>
                    </div>
                    <div class="cipher-title">Pigpen Cipher</div>
                </div>
                <div class="cipher-description">
                    Masonic cipher using geometric symbols
                </div>
                <div class="input-group">
                    <label class="input-label">Text to Encode/Decode</label>
                    <input type="text" id="pigpenInput" class="cipher-input" placeholder="e.g., HELLO">
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="pigpenEncode()">
                        <i class="fas fa-lock"></i>
                        Encode
                    </button>
                    <button class="btn btn-primary" onclick="pigpenDecode()">
                        <i class="fas fa-unlock"></i>
                        Decode
                    </button>
                    <button class="btn btn-secondary" onclick="clearCipher('pigpen')">
                        <i class="fas fa-eraser"></i>
                        Clear
                    </button>
                </div>
                <div class="results-container" id="pigpenResults" style="display: none;"></div>
            </div>

            <!-- Polybius Square -->
            <div class="cipher-card">
                <div class="cipher-header">
                    <div class="cipher-icon">
                        <i class="fas fa-th"></i>
                    </div>
                    <div class="cipher-title">Polybius Square</div>
                </div>
                <div class="cipher-description">
                    Convert letters to coordinates (I/J share position)
                </div>
                <div class="input-group">
                    <label class="input-label">Text to Encode/Decode</label>
                    <input type="text" id="polybiusInput" class="cipher-input" placeholder="e.g., HELLO WORLD">
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="polybiusEncode()">
                        <i class="fas fa-lock"></i>
                        Encode
                    </button>
                    <button class="btn btn-primary" onclick="polybiusDecode()">
                        <i class="fas fa-unlock"></i>
                        Decode
                    </button>
                    <button class="btn btn-secondary" onclick="clearCipher('polybius')">
                        <i class="fas fa-eraser"></i>
                        Clear
                    </button>
                </div>
                <div class="results-container" id="polybiusResults" style="display: none;"></div>
            </div>

            <!-- Nihilist Cipher -->
            <div class="cipher-card">
                <div class="cipher-header">
                    <div class="cipher-icon">
                        <i class="fas fa-hashtag"></i>
                    </div>
                    <div class="cipher-title">Nihilist Cipher</div>
                </div>
                <div class="cipher-description">
                    Polybius square with keyword addition
                </div>
                <div class="input-group">
                    <label class="input-label">Keyword</label>
                    <input type="text" id="nihilistKey" class="key-input" placeholder="e.g., SECRET" maxlength="26">
                </div>
                <div class="input-group">
                    <label class="input-label">Text to Encode/Decode</label>
                    <input type="text" id="nihilistInput" class="cipher-input" placeholder="e.g., HELLO WORLD">
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="nihilistEncode()">
                        <i class="fas fa-lock"></i>
                        Encode
                    </button>
                    <button class="btn btn-primary" onclick="nihilistDecode()">
                        <i class="fas fa-unlock"></i>
                        Decode
                    </button>
                    <button class="btn btn-secondary" onclick="clearCipher('nihilist')">
                        <i class="fas fa-eraser"></i>
                        Clear
                    </button>
                </div>
                <div class="results-container" id="nihilistResults" style="display: none;"></div>
            </div>

            <!-- Homophonic Substitution -->
            <div class="cipher-card">
                <div class="cipher-header">
                    <div class="cipher-icon">
                        <i class="fas fa-layer-group"></i>
                    </div>
                    <div class="cipher-title">Homophonic Substitution</div>
                </div>
                <div class="cipher-description">
                    Multiple symbols for common letters to hide frequency
                </div>
                <div class="input-group">
                    <label class="input-label">Text to Encode/Decode</label>
                    <input type="text" id="homophonicInput" class="cipher-input" placeholder="e.g., HELLO WORLD">
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="homophonicEncode()">
                        <i class="fas fa-lock"></i>
                        Encode
                    </button>
                    <button class="btn btn-primary" onclick="homophonicDecode()">
                        <i class="fas fa-unlock"></i>
                        Decode
                    </button>
                    <button class="btn btn-secondary" onclick="clearCipher('homophonic')">
                        <i class="fas fa-eraser"></i>
                        Clear
                    </button>
                </div>
                <div class="results-container" id="homophonicResults" style="display: none;"></div>
            </div>

            <!-- Playfair Cipher -->
            <div class="cipher-card">
                <div class="cipher-header">
                    <div class="cipher-icon">
                        <i class="fas fa-table"></i>
                    </div>
                    <div class="cipher-title">Playfair Cipher</div>
                </div>
                <div class="cipher-description">
                    Digraphic substitution using a 5x5 key square
                </div>
                <div class="input-group">
                    <label class="input-label">Keyword</label>
                    <input type="text" id="playfairKey" class="key-input" placeholder="e.g., MONARCHY" maxlength="25">
                </div>
                <div class="input-group">
                    <label class="input-label">Text to Encode/Decode</label>
                    <input type="text" id="playfairInput" class="cipher-input" placeholder="e.g., HELLO WORLD">
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="playfairEncode()">
                        <i class="fas fa-lock"></i>
                        Encode
                    </button>
                    <button class="btn btn-primary" onclick="playfairDecode()">
                        <i class="fas fa-unlock"></i>
                        Decode
                    </button>
                    <button class="btn btn-secondary" onclick="clearCipher('playfair')">
                        <i class="fas fa-eraser"></i>
                        Clear
                    </button>
                </div>
                <div class="results-container" id="playfairResults" style="display: none;"></div>
            </div>
        </div>

        <!-- Error/Success Messages -->
        <div id="messageContainer"></div>
    </div>

    <!-- Scripts -->
    <script src="shared-loader.js"></script>
    <script src="mobile-nav.js"></script>
    <script src="sphere-loader.js"></script>

    <script>
        // Substitution Ciphers Logic
        class CipherManager {
            constructor() {
                this.setupEventListeners();
            }

            setupEventListeners() {
                // Auto-encode on input change for some ciphers
                const inputs = ['caesarInput', 'rot13Input', 'atbashInput', 'morseInput'];
                inputs.forEach(id => {
                    const input = document.getElementById(id);
                    if (input) {
                        input.addEventListener('keypress', (e) => {
                            if (e.key === 'Enter') {
                                this.handleEnterPress(e.target);
                            }
                        });
                    }
                });
            }

            handleEnterPress(input) {
                const id = input.id;
                if (id === 'caesarInput') {
                    caesarEncode();
                } else if (id === 'rot13Input') {
                    rot13Encode();
                } else if (id === 'atbashInput') {
                    atbashEncode();
                } else if (id === 'morseInput') {
                    morseEncode();
                }
            }

            handleInputChange(input) {
                const value = input.value.trim();
                if (!value) {
                    this.hideResults();
                    return;
                }

                const inputId = input.id;
                let isValid = false;
                let decimalValue = null;

                try {
                    switch (inputId) {
                        case 'binaryInput':
                            if (this.isValidBinary(value)) {
                                decimalValue = parseInt(value, 2);
                                isValid = true;
                            }
                            break;
                        case 'decimalInput':
                            if (this.isValidDecimal(value)) {
                                decimalValue = parseInt(value, 10);
                                isValid = true;
                            }
                            break;
                        case 'hexInput':
                            if (this.isValidHex(value)) {
                                decimalValue = parseInt(value, 16);
                                isValid = true;
                            }
                            break;
                        case 'octalInput':
                            if (this.isValidOctal(value)) {
                                decimalValue = parseInt(value, 8);
                                isValid = true;
                            }
                            break;
                    }

                    if (isValid && decimalValue !== null) {
                        this.convertAll(decimalValue);
                        this.showSuccessMessage('Conversion successful!');
                    } else {
                        this.showErrorMessage('Invalid input format. Please check your input.');
                    }
                } catch (error) {
                    this.showErrorMessage('Conversion error: ' + error.message);
                }
            }

            isValidBinary(value) {
                return /^[01]+$/.test(value);
            }

            isValidDecimal(value) {
                return /^\d+$/.test(value) && parseInt(value) >= 0;
            }

            isValidHex(value) {
                return /^[0-9A-Fa-f]+$/.test(value);
            }

            isValidOctal(value) {
                return /^[0-7]+$/.test(value);
            }

            convertAll(decimalValue) {
                this.results = {
                    decimal: decimalValue.toString(),
                    binary: decimalValue.toString(2),
                    hex: decimalValue.toString(16).toUpperCase(),
                    octal: decimalValue.toString(8)
                };

                this.displayResults();
                this.updateInputs();
                this.createBinaryVisualization();
            }

            displayResults() {
                const container = document.getElementById('resultsContainer');
                const content = document.getElementById('resultsContent');
                
                content.innerHTML = `
                    <div class="result-item">
                        <span class="result-label">Decimal (Base-10):</span>
                        <span class="result-value" onclick="copyToClipboard('${this.results.decimal}')">${this.results.decimal}</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">Binary (Base-2):</span>
                        <span class="result-value" onclick="copyToClipboard('${this.results.binary}')">${this.results.binary}</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">Hexadecimal (Base-16):</span>
                        <span class="result-value" onclick="copyToClipboard('${this.results.hex}')">${this.results.hex}</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">Octal (Base-8):</span>
                        <span class="result-value" onclick="copyToClipboard('${this.results.octal}')">${this.results.octal}</span>
                    </div>
                `;
                
                container.style.display = 'block';
            }

            updateInputs() {
                document.getElementById('binaryInput').value = this.results.binary;
                document.getElementById('decimalInput').value = this.results.decimal;
                document.getElementById('hexInput').value = this.results.hex;
                document.getElementById('octalInput').value = this.results.octal;
            }

            createBinaryVisualization() {
                const container = document.getElementById('binaryVisualization');
                const bitsContainer = document.getElementById('binaryBits');
                
                // Pad binary to 8 bits for better visualization
                let binary = this.results.binary;
                while (binary.length < 8) {
                    binary = '0' + binary;
                }
                
                // Limit to 32 bits for display
                if (binary.length > 32) {
                    binary = binary.slice(-32);
                }

                bitsContainer.innerHTML = '';
                
                for (let i = 0; i < binary.length; i++) {
                    const bit = document.createElement('div');
                    bit.className = `bit bit-${binary[i]}`;
                    bit.textContent = binary[i];
                    bit.title = `Bit ${binary.length - 1 - i} (${binary[i]})`;
                    bitsContainer.appendChild(bit);
                }
                
                container.style.display = 'block';
            }

            hideResults() {
                document.getElementById('resultsContainer').style.display = 'none';
                document.getElementById('binaryVisualization').style.display = 'none';
            }

            showSuccessMessage(message) {
                this.showMessage(message, 'success');
            }

            showErrorMessage(message) {
                this.showMessage(message, 'error');
            }

            showMessage(message, type) {
                const container = document.getElementById('messageContainer');
                container.innerHTML = `<div class="${type}-message">${message}</div>`;
                
                setTimeout(() => {
                    container.innerHTML = '';
                }, 5000);
            }
        }

        // Global cipher manager instance
        const cipherManager = new CipherManager();

        // Caesar Cipher Functions
        function caesarEncode() {
            const text = document.getElementById('caesarInput').value.toUpperCase();
            const key = parseInt(document.getElementById('caesarKey').value) || 3;
            
            if (!text) {
                showMessage('Please enter text to encode', 'error');
                return;
            }
            
            const result = caesarCipher(text, key);
            showResult('caesarResults', 'Encoded:', result);
        }

        function caesarDecode() {
            const text = document.getElementById('caesarInput').value.toUpperCase();
            const key = parseInt(document.getElementById('caesarKey').value) || 3;
            
            if (!text) {
                showMessage('Please enter text to decode', 'error');
                return;
            }
            
            const result = caesarCipher(text, -key);
            showResult('caesarResults', 'Decoded:', result);
        }

        function caesarCipher(text, shift) {
            return text.split('').map(char => {
                if (char >= 'A' && char <= 'Z') {
                    const code = char.charCodeAt(0) - 65;
                    const shifted = (code + shift + 26) % 26;
                    return String.fromCharCode(shifted + 65);
                }
                return char;
            }).join('');
        }

        // ROT13 Functions
        function rot13Encode() {
            const text = document.getElementById('rot13Input').value.toUpperCase();
            
            if (!text) {
                showMessage('Please enter text to encode/decode', 'error');
                return;
            }
            
            const result = caesarCipher(text, 13);
            showResult('rot13Results', 'Result:', result);
        }

        // Atbash Functions
        function atbashEncode() {
            const text = document.getElementById('atbashInput').value.toUpperCase();
            
            if (!text) {
                showMessage('Please enter text to encode/decode', 'error');
                return;
            }
            
            const result = text.split('').map(char => {
                if (char >= 'A' && char <= 'Z') {
                    return String.fromCharCode(90 - (char.charCodeAt(0) - 65));
                }
                return char;
            }).join('');
            
            showResult('atbashResults', 'Result:', result);
        }

        // Simple Substitution Functions
        function substitutionEncode() {
            const text = document.getElementById('substitutionInput').value.toUpperCase();
            const key = document.getElementById('substitutionKey').value.toUpperCase();
            
            if (!text || !key || key.length !== 26) {
                showMessage('Please enter text and a 26-letter substitution key', 'error');
                return;
            }
            
            const result = text.split('').map(char => {
                if (char >= 'A' && char <= 'Z') {
                    return key[char.charCodeAt(0) - 65];
                }
                return char;
            }).join('');
            
            showResult('substitutionResults', 'Encoded:', result);
        }

        function substitutionDecode() {
            const text = document.getElementById('substitutionInput').value.toUpperCase();
            const key = document.getElementById('substitutionKey').value.toUpperCase();
            
            if (!text || !key || key.length !== 26) {
                showMessage('Please enter text and a 26-letter substitution key', 'error');
                return;
            }
            
            const result = text.split('').map(char => {
                if (char >= 'A' && char <= 'Z') {
                    const index = key.indexOf(char);
                    return String.fromCharCode(index + 65);
                }
                return char;
            }).join('');
            
            showResult('substitutionResults', 'Decoded:', result);
        }

        // Keyword Cipher Functions
        function keywordEncode() {
            const text = document.getElementById('keywordInput').value.toUpperCase();
            const keyword = document.getElementById('keywordKey').value.toUpperCase();
            
            if (!text || !keyword) {
                showMessage('Please enter text and keyword', 'error');
                return;
            }
            
            const key = generateKeywordAlphabet(keyword);
            const result = text.split('').map(char => {
                if (char >= 'A' && char <= 'Z') {
                    return key[char.charCodeAt(0) - 65];
                }
                return char;
            }).join('');
            
            showResult('keywordResults', 'Encoded:', result);
        }

        function keywordDecode() {
            const text = document.getElementById('keywordInput').value.toUpperCase();
            const keyword = document.getElementById('keywordKey').value.toUpperCase();
            
            if (!text || !keyword) {
                showMessage('Please enter text and keyword', 'error');
                return;
            }
            
            const key = generateKeywordAlphabet(keyword);
            const result = text.split('').map(char => {
                if (char >= 'A' && char <= 'Z') {
                    const index = key.indexOf(char);
                    return String.fromCharCode(index + 65);
                }
                return char;
            }).join('');
            
            showResult('keywordResults', 'Decoded:', result);
        }

        function generateKeywordAlphabet(keyword) {
            const used = new Set();
            let result = '';
            
            // Add keyword letters first
            for (let char of keyword) {
                if (char >= 'A' && char <= 'Z' && !used.has(char)) {
                    result += char;
                    used.add(char);
                }
            }
            
            // Add remaining alphabet letters
            for (let i = 65; i <= 90; i++) {
                const char = String.fromCharCode(i);
                if (!used.has(char)) {
                    result += char;
                }
            }
            
            return result;
        }

        // Affine Cipher Functions
        function affineEncode() {
            const text = document.getElementById('affineInput').value.toUpperCase();
            const a = parseInt(document.getElementById('affineA').value);
            const b = parseInt(document.getElementById('affineB').value);
            
            if (!text || !a || !b) {
                showMessage('Please enter text and valid a, b values', 'error');
                return;
            }
            
            if (gcd(a, 26) !== 1) {
                showMessage('Value a must be coprime with 26', 'error');
                return;
            }
            
            const result = text.split('').map(char => {
                if (char >= 'A' && char <= 'Z') {
                    const x = char.charCodeAt(0) - 65;
                    const y = (a * x + b) % 26;
                    return String.fromCharCode(y + 65);
                }
                return char;
            }).join('');
            
            showResult('affineResults', 'Encoded:', result);
        }

        function affineDecode() {
            const text = document.getElementById('affineInput').value.toUpperCase();
            const a = parseInt(document.getElementById('affineA').value);
            const b = parseInt(document.getElementById('affineB').value);
            
            if (!text || !a || !b) {
                showMessage('Please enter text and valid a, b values', 'error');
                return;
            }
            
            if (gcd(a, 26) !== 1) {
                showMessage('Value a must be coprime with 26', 'error');
                return;
            }
            
            const aInv = modInverse(a, 26);
            const result = text.split('').map(char => {
                if (char >= 'A' && char <= 'Z') {
                    const y = char.charCodeAt(0) - 65;
                    const x = (aInv * (y - b + 26)) % 26;
                    return String.fromCharCode(x + 65);
                }
                return char;
            }).join('');
            
            showResult('affineResults', 'Decoded:', result);
        }

        function gcd(a, b) {
            return b === 0 ? a : gcd(b, a % b);
        }

        function modInverse(a, m) {
            for (let x = 1; x < m; x++) {
                if (((a % m) * (x % m)) % m === 1) {
                    return x;
                }
            }
            return 1;
        }

        // Bacon Cipher Functions
        function baconEncode() {
            const text = document.getElementById('baconInput').value.toUpperCase();
            
            if (!text) {
                showMessage('Please enter text to encode', 'error');
                return;
            }
            
            const baconMap = {
                'A': '00000', 'B': '00001', 'C': '00010', 'D': '00011', 'E': '00100',
                'F': '00101', 'G': '00110', 'H': '00111', 'I': '01000', 'J': '01001',
                'K': '01010', 'L': '01011', 'M': '01100', 'N': '01101', 'O': '01110',
                'P': '01111', 'Q': '10000', 'R': '10001', 'S': '10010', 'T': '10011',
                'U': '10100', 'V': '10101', 'W': '10110', 'X': '10111', 'Y': '11000',
                'Z': '11001'
            };
            
            const result = text.split('').map(char => {
                if (char >= 'A' && char <= 'Z') {
                    return baconMap[char] || char;
                }
                return char;
            }).join(' ');
            
            showResult('baconResults', 'Encoded:', result);
        }

        function baconDecode() {
            const text = document.getElementById('baconInput').value;
            
            if (!text) {
                showMessage('Please enter binary code to decode', 'error');
                return;
            }
            
            const baconMap = {
                '00000': 'A', '00001': 'B', '00010': 'C', '00011': 'D', '00100': 'E',
                '00101': 'F', '00110': 'G', '00111': 'H', '01000': 'I', '01001': 'J',
                '01010': 'K', '01011': 'L', '01100': 'M', '01101': 'N', '01110': 'O',
                '01111': 'P', '10000': 'Q', '10001': 'R', '10010': 'S', '10011': 'T',
                '10100': 'U', '10101': 'V', '10110': 'W', '10111': 'X', '11000': 'Y',
                '11001': 'Z'
            };
            
            const binary = text.replace(/\s/g, '');
            let result = '';
            
            for (let i = 0; i < binary.length; i += 5) {
                const code = binary.substr(i, 5);
                if (baconMap[code]) {
                    result += baconMap[code];
                } else {
                    result += '?';
                }
            }
            
            showResult('baconResults', 'Decoded:', result);
        }

        // Morse Code Functions
        function morseEncode() {
            const text = document.getElementById('morseInput').value.toUpperCase();
            
            if (!text) {
                showMessage('Please enter text to encode', 'error');
                return;
            }
            
            const morseMap = {
                'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
                'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
                'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
                'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
                'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',
                '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',
                '8': '---..', '9': '----.', ' ': '/'
            };
            
            const result = text.split('').map(char => {
                return morseMap[char] || char;
            }).join(' ');
            
            showResult('morseResults', 'Encoded:', result);
        }

        function morseDecode() {
            const text = document.getElementById('morseInput').value;
            
            if (!text) {
                showMessage('Please enter morse code to decode', 'error');
                return;
            }
            
            const morseMap = {
                '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E', '..-.': 'F',
                '--.': 'G', '....': 'H', '..': 'I', '.---': 'J', '-.-': 'K', '.-..': 'L',
                '--': 'M', '-.': 'N', '---': 'O', '.--.': 'P', '--.-': 'Q', '.-.': 'R',
                '...': 'S', '-': 'T', '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X',
                '-.--': 'Y', '--..': 'Z', '-----': '0', '.----': '1', '..---': '2',
                '...--': '3', '....-': '4', '.....': '5', '-....': '6', '--...': '7',
                '---..': '8', '----.': '9', '/': ' '
            };
            
            const result = text.split(' ').map(code => {
                return morseMap[code] || code;
            }).join('');
            
            showResult('morseResults', 'Decoded:', result);
        }

        // Pigpen Cipher Functions
        function pigpenEncode() {
            const text = document.getElementById('pigpenInput').value.toUpperCase();
            
            if (!text) {
                showMessage('Please enter text to encode', 'error');
                return;
            }
            
            const pigpenMap = {
                'A': '┌─', 'B': '┌┐', 'C': '┌┘', 'D': '─┐', 'E': '─┘', 'F': '┐─',
                'G': '┐┘', 'H': '┘─', 'I': '┘┐', 'J': '┌─', 'K': '┌┐', 'L': '┌┘',
                'M': '─┐', 'N': '─┘', 'O': '┐─', 'P': '┐┘', 'Q': '┘─', 'R': '┘┐',
                'S': '◢', 'T': '◣', 'U': '◤', 'V': '◥', 'W': '◢', 'X': '◣', 'Y': '◤', 'Z': '◥'
            };
            
            const result = text.split('').map(char => {
                if (char >= 'A' && char <= 'Z') {
                    return pigpenMap[char] || char;
                }
                return char;
            }).join('');
            
            showResult('pigpenResults', 'Encoded:', result);
        }

        function pigpenDecode() {
            const text = document.getElementById('pigpenInput').value;
            
            if (!text) {
                showMessage('Please enter pigpen symbols to decode', 'error');
                return;
            }
            
            const pigpenMap = {
                '┌─': 'A', '┌┐': 'B', '┌┘': 'C', '─┐': 'D', '─┘': 'E', '┐─': 'F',
                '┐┘': 'G', '┘─': 'H', '┘┐': 'I', '◢': 'S', '◣': 'T', '◤': 'U', '◥': 'V'
            };
            
            // Simple decoding - this is a basic implementation
            let result = text;
            for (let [symbol, letter] of Object.entries(pigpenMap)) {
                result = result.replace(new RegExp(symbol, 'g'), letter);
            }
            
            showResult('pigpenResults', 'Decoded:', result);
        }

        // Polybius Square Functions
        function polybiusEncode() {
            const text = document.getElementById('polybiusInput').value.toUpperCase();
            
            if (!text) {
                showMessage('Please enter text to encode', 'error');
                return;
            }
            
            const polybiusSquare = [
                ['A', 'B', 'C', 'D', 'E'],
                ['F', 'G', 'H', 'I/J', 'K'],
                ['L', 'M', 'N', 'O', 'P'],
                ['Q', 'R', 'S', 'T', 'U'],
                ['V', 'W', 'X', 'Y', 'Z']
            ];
            
            const result = text.split('').map(char => {
                if (char === 'I' || char === 'J') {
                    return '24';
                }
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 5; j++) {
                        if (polybiusSquare[i][j] === char) {
                            return `${i + 1}${j + 1}`;
                        }
                    }
                }
                return char;
            }).join('');
            
            showResult('polybiusResults', 'Encoded:', result);
        }

        function polybiusDecode() {
            const text = document.getElementById('polybiusInput').value;
            
            if (!text) {
                showMessage('Please enter coordinates to decode', 'error');
                return;
            }
            
            const polybiusSquare = [
                ['A', 'B', 'C', 'D', 'E'],
                ['F', 'G', 'H', 'I/J', 'K'],
                ['L', 'M', 'N', 'O', 'P'],
                ['Q', 'R', 'S', 'T', 'U'],
                ['V', 'W', 'X', 'Y', 'Z']
            ];
            
            let result = '';
            for (let i = 0; i < text.length; i += 2) {
                const row = parseInt(text[i]) - 1;
                const col = parseInt(text[i + 1]) - 1;
                if (row >= 0 && row < 5 && col >= 0 && col < 5) {
                    result += polybiusSquare[row][col];
                } else {
                    result += '?';
                }
            }
            
            showResult('polybiusResults', 'Decoded:', result);
        }

        // Nihilist Cipher Functions
        function nihilistEncode() {
            const text = document.getElementById('nihilistInput').value.toUpperCase();
            const keyword = document.getElementById('nihilistKey').value.toUpperCase();
            
            if (!text || !keyword) {
                showMessage('Please enter text and keyword', 'error');
                return;
            }
            
            // First encode with Polybius
            const polybiusResult = polybiusEncodeInternal(text);
            
            // Then add keyword
            const keywordRepeated = keyword.repeat(Math.ceil(polybiusResult.length / keyword.length)).substring(0, polybiusResult.length);
            const keywordNums = keywordRepeated.split('').map(char => {
                if (char >= 'A' && char <= 'Z') {
                    return char.charCodeAt(0) - 64;
                }
                return 0;
            });
            
            const result = polybiusResult.split('').map((char, i) => {
                if (char >= '0' && char <= '9') {
                    const sum = parseInt(char) + keywordNums[i % keywordNums.length];
                    return sum.toString();
                }
                return char;
            }).join('');
            
            showResult('nihilistResults', 'Encoded:', result);
        }

        function nihilistDecode() {
            const text = document.getElementById('nihilistInput').value;
            const keyword = document.getElementById('nihilistKey').value.toUpperCase();
            
            if (!text || !keyword) {
                showMessage('Please enter text and keyword', 'error');
                return;
            }
            
            // Subtract keyword first
            const keywordRepeated = keyword.repeat(Math.ceil(text.length / keyword.length)).substring(0, text.length);
            const keywordNums = keywordRepeated.split('').map(char => {
                if (char >= 'A' && char <= 'Z') {
                    return char.charCodeAt(0) - 64;
                }
                return 0;
            });
            
            const subtracted = text.split('').map((char, i) => {
                if (char >= '0' && char <= '9') {
                    const diff = parseInt(char) - keywordNums[i % keywordNums.length];
                    return Math.max(0, diff).toString();
                }
                return char;
            }).join('');
            
            // Then decode with Polybius
            const result = polybiusDecodeInternal(subtracted);
            showResult('nihilistResults', 'Decoded:', result);
        }

        function polybiusEncodeInternal(text) {
            const polybiusSquare = [
                ['A', 'B', 'C', 'D', 'E'],
                ['F', 'G', 'H', 'I/J', 'K'],
                ['L', 'M', 'N', 'O', 'P'],
                ['Q', 'R', 'S', 'T', 'U'],
                ['V', 'W', 'X', 'Y', 'Z']
            ];
            
            return text.split('').map(char => {
                if (char === 'I' || char === 'J') {
                    return '24';
                }
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 5; j++) {
                        if (polybiusSquare[i][j] === char) {
                            return `${i + 1}${j + 1}`;
                        }
                    }
                }
                return char;
            }).join('');
        }

        function polybiusDecodeInternal(text) {
            const polybiusSquare = [
                ['A', 'B', 'C', 'D', 'E'],
                ['F', 'G', 'H', 'I/J', 'K'],
                ['L', 'M', 'N', 'O', 'P'],
                ['Q', 'R', 'S', 'T', 'U'],
                ['V', 'W', 'X', 'Y', 'Z']
            ];
            
            let result = '';
            for (let i = 0; i < text.length; i += 2) {
                const row = parseInt(text[i]) - 1;
                const col = parseInt(text[i + 1]) - 1;
                if (row >= 0 && row < 5 && col >= 0 && col < 5) {
                    result += polybiusSquare[row][col];
                } else {
                    result += '?';
                }
            }
            return result;
        }

        // Homophonic Substitution Functions
        function homophonicEncode() {
            const text = document.getElementById('homophonicInput').value.toUpperCase();
            
            if (!text) {
                showMessage('Please enter text to encode', 'error');
                return;
            }
            
            const homophonicMap = {
                'A': ['01', '02', '03'], 'B': ['04'], 'C': ['05', '06'], 'D': ['07', '08'],
                'E': ['09', '10', '11', '12', '13'], 'F': ['14'], 'G': ['15'], 'H': ['16'],
                'I': ['17', '18', '19'], 'J': ['20'], 'K': ['21'], 'L': ['22', '23'],
                'M': ['24'], 'N': ['25', '26', '27'], 'O': ['28', '29', '30'], 'P': ['31'],
                'Q': ['32'], 'R': ['33', '34', '35'], 'S': ['36', '37', '38'], 'T': ['39', '40', '41'],
                'U': ['42', '43'], 'V': ['44'], 'W': ['45'], 'X': ['46'], 'Y': ['47'], 'Z': ['48']
            };
            
            const result = text.split('').map(char => {
                if (char >= 'A' && char <= 'Z') {
                    const options = homophonicMap[char];
                    if (options) {
                        return options[Math.floor(Math.random() * options.length)];
                    }
                }
                return char;
            }).join(' ');
            
            showResult('homophonicResults', 'Encoded:', result);
        }

        function homophonicDecode() {
            const text = document.getElementById('homophonicInput').value;
            
            if (!text) {
                showMessage('Please enter numbers to decode', 'error');
                return;
            }
            
            const homophonicMap = {
                '01': 'A', '02': 'A', '03': 'A', '04': 'B', '05': 'C', '06': 'C',
                '07': 'D', '08': 'D', '09': 'E', '10': 'E', '11': 'E', '12': 'E', '13': 'E',
                '14': 'F', '15': 'G', '16': 'H', '17': 'I', '18': 'I', '19': 'I',
                '20': 'J', '21': 'K', '22': 'L', '23': 'L', '24': 'M', '25': 'N',
                '26': 'N', '27': 'N', '28': 'O', '29': 'O', '30': 'O', '31': 'P',
                '32': 'Q', '33': 'R', '34': 'R', '35': 'R', '36': 'S', '37': 'S',
                '38': 'S', '39': 'T', '40': 'T', '41': 'T', '42': 'U', '43': 'U',
                '44': 'V', '45': 'W', '46': 'X', '47': 'Y', '48': 'Z'
            };
            
            const result = text.split(' ').map(num => {
                return homophonicMap[num] || num;
            }).join('');
            
            showResult('homophonicResults', 'Decoded:', result);
        }

        // Playfair Cipher Functions
        function playfairEncode() {
            const text = document.getElementById('playfairInput').value.toUpperCase();
            const keyword = document.getElementById('playfairKey').value.toUpperCase();
            
            if (!text || !keyword) {
                showMessage('Please enter text and keyword', 'error');
                return;
            }
            
            const keySquare = generatePlayfairKeySquare(keyword);
            const digraphs = prepareTextForPlayfair(text);
            let result = '';
            
            for (let i = 0; i < digraphs.length; i += 2) {
                const char1 = digraphs[i];
                const char2 = digraphs[i + 1] || 'X';
                result += playfairEncodeDigraph(char1, char2, keySquare);
            }
            
            showResult('playfairResults', 'Encoded:', result);
        }

        function playfairDecode() {
            const text = document.getElementById('playfairInput').value.toUpperCase();
            const keyword = document.getElementById('playfairKey').value.toUpperCase();
            
            if (!text || !keyword) {
                showMessage('Please enter text and keyword', 'error');
                return;
            }
            
            const keySquare = generatePlayfairKeySquare(keyword);
            let result = '';
            
            for (let i = 0; i < text.length; i += 2) {
                const char1 = text[i];
                const char2 = text[i + 1];
                result += playfairDecodeDigraph(char1, char2, keySquare);
            }
            
            showResult('playfairResults', 'Decoded:', result);
        }

        function generatePlayfairKeySquare(keyword) {
            const used = new Set();
            const square = [];
            let index = 0;
            
            // Add keyword letters first
            for (let char of keyword) {
                if (char >= 'A' && char <= 'Z' && !used.has(char)) {
                    if (char === 'I' || char === 'J') {
                        if (!used.has('I') && !used.has('J')) {
                            used.add('I');
                            used.add('J');
                            square[index] = 'I';
                            index++;
                        }
                    } else {
                        used.add(char);
                        square[index] = char;
                        index++;
                    }
                }
            }
            
            // Add remaining alphabet letters
            for (let i = 65; i <= 90; i++) {
                const char = String.fromCharCode(i);
                if (char === 'I' || char === 'J') {
                    if (!used.has('I') && !used.has('J')) {
                        used.add('I');
                        used.add('J');
                        square[index] = 'I';
                        index++;
                    }
                } else if (!used.has(char)) {
                    used.add(char);
                    square[index] = char;
                    index++;
                }
            }
            
            return square;
        }

        function prepareTextForPlayfair(text) {
            let prepared = text.replace(/[^A-Z]/g, '');
            let result = '';
            
            for (let i = 0; i < prepared.length; i++) {
                if (i > 0 && prepared[i] === prepared[i - 1]) {
                    result += 'X';
                }
                result += prepared[i];
            }
            
            if (result.length % 2 === 1) {
                result += 'X';
            }
            
            return result;
        }

        function playfairEncodeDigraph(char1, char2, keySquare) {
            const pos1 = keySquare.indexOf(char1);
            const pos2 = keySquare.indexOf(char2);
            const row1 = Math.floor(pos1 / 5);
            const col1 = pos1 % 5;
            const row2 = Math.floor(pos2 / 5);
            const col2 = pos2 % 5;
            
            if (row1 === row2) {
                return keySquare[row1 * 5 + ((col1 + 1) % 5)] + keySquare[row2 * 5 + ((col2 + 1) % 5)];
            } else if (col1 === col2) {
                return keySquare[((row1 + 1) % 5) * 5 + col1] + keySquare[((row2 + 1) % 5) * 5 + col2];
            } else {
                return keySquare[row1 * 5 + col2] + keySquare[row2 * 5 + col1];
            }
        }

        function playfairDecodeDigraph(char1, char2, keySquare) {
            const pos1 = keySquare.indexOf(char1);
            const pos2 = keySquare.indexOf(char2);
            const row1 = Math.floor(pos1 / 5);
            const col1 = pos1 % 5;
            const row2 = Math.floor(pos2 / 5);
            const col2 = pos2 % 5;
            
            if (row1 === row2) {
                return keySquare[row1 * 5 + ((col1 + 4) % 5)] + keySquare[row2 * 5 + ((col2 + 4) % 5)];
            } else if (col1 === col2) {
                return keySquare[((row1 + 4) % 5) * 5 + col1] + keySquare[((row2 + 4) % 5) * 5 + col2];
            } else {
                return keySquare[row1 * 5 + col2] + keySquare[row2 * 5 + col1];
            }
        }

        // Utility Functions
        function showResult(containerId, label, result) {
            const container = document.getElementById(containerId);
            container.innerHTML = `
                <div class="result-item">
                    <span class="result-label">${label}</span>
                    <span class="result-value" onclick="copyToClipboard('${result}')">${result}</span>
                </div>
            `;
            container.style.display = 'block';
        }

        function clearCipher(cipherType) {
            const inputId = cipherType + 'Input';
            const keyId = cipherType + 'Key';
            const resultsId = cipherType + 'Results';
            
            if (document.getElementById(inputId)) {
                document.getElementById(inputId).value = '';
            }
            if (document.getElementById(keyId)) {
                document.getElementById(keyId).value = '';
            }
            if (document.getElementById(resultsId)) {
                document.getElementById(resultsId).style.display = 'none';
            }
            
            document.getElementById('messageContainer').innerHTML = '';
        }

        function showMessage(message, type) {
            const container = document.getElementById('messageContainer');
            container.innerHTML = `<div class="${type}-message">${message}</div>`;
            
            setTimeout(() => {
                container.innerHTML = '';
            }, 5000);
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                // Visual feedback
                const elements = document.querySelectorAll('.result-value');
                elements.forEach(el => {
                    if (el.textContent === text) {
                        el.classList.add('copy-animation');
                        setTimeout(() => {
                            el.classList.remove('copy-animation');
                        }, 500);
                    }
                });
                
                showMessage(`Copied "${text}" to clipboard!`, 'success');
            }).catch(err => {
                showMessage('Failed to copy to clipboard', 'error');
            });
        }

        // Initialize tooltips and additional features
        document.addEventListener('DOMContentLoaded', () => {
            // Add tooltips to result values
            const resultValues = document.querySelectorAll('.result-value');
            resultValues.forEach(el => {
                el.title = 'Click to copy';
            });

            // Auto-focus first input
            document.getElementById('caesarInput').focus();
        });
    </script>
</body>
</html>
